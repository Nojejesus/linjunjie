{"meta":{"title":"Talk is cheap, show you my code.","subtitle":"千里之行，始于足下","description":"苟利国家生死以，岂因祸福避趋之","author":"Junjie Lin","url":"https://nojejesus.github.io/techTube","root":"/techTube/"},"pages":[{},{},{}],"posts":[{"title":"数据库和缓存一致性问题","date":"2019-07-20T14:37:55.000Z","path":"2019/07/20/数据库和缓存一致性问题/","text":"DB和缓存同时操作的一致性问题缓存中的数据和数据源并非总是一致的，应用程序必须实现一种帮助确保缓存和数据源一致的策略。这种策略不仅能够确保缓存里的数据是最新的，而且当缓存中的数据不是最新的时候，需要能被监测到并采取响应措施。（待续：https://coding.imooc.com/learn/questiondetail/105625.html）","raw":"---\ntitle: 数据库和缓存一致性问题\ndate: 2019-07-20 22:37:55\ntags:\n- 数据库\n- 缓存\ncategories:\n- 数据库\n---\n##### DB和缓存同时操作的一致性问题\n缓存中的数据和数据源并非总是一致的，应用程序必须实现一种帮助确保缓存和数据源一致的策略。这种策略不仅能够确保缓存里的数据是最新的，而且当缓存中的数据不是最新的时候，需要能被监测到并采取响应措施。\n（待续：https://coding.imooc.com/learn/questiondetail/105625.html）\n<!-- more -->","content":"<h5 id=\"DB和缓存同时操作的一致性问题\"><a href=\"#DB和缓存同时操作的一致性问题\" class=\"headerlink\" title=\"DB和缓存同时操作的一致性问题\"></a>DB和缓存同时操作的一致性问题</h5><p>缓存中的数据和数据源并非总是一致的，应用程序必须实现一种帮助确保缓存和数据源一致的策略。这种策略不仅能够确保缓存里的数据是最新的，而且当缓存中的数据不是最新的时候，需要能被监测到并采取响应措施。<br>（待续：<a href=\"https://coding.imooc.com/learn/questiondetail/105625.html）\" target=\"_blank\" rel=\"noopener\">https://coding.imooc.com/learn/questiondetail/105625.html）</a></p>\n<a id=\"more\"></a>","slug":"数据库和缓存一致性问题","updated":"2019-07-20T14:59:30.889Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/20/数据库和缓存一致性问题/","excerpt":"DB和缓存同时操作的一致性问题缓存中的数据和数据源并非总是一致的，应用程序必须实现一种帮助确保缓存和数据源一致的策略。这种策略不仅能够确保缓存里的数据是最新的，而且当缓存中的数据不是最新的时候，需要能被监测到并采取响应措施。（待续：https://coding.imooc.com/learn/questiondetail/105625.html）","categories":[{"name":"数据库","slug":"数据库","permalink":"https://nojejesus.github.io/techTube/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://nojejesus.github.io/techTube/tags/数据库/"},{"name":"缓存","slug":"缓存","permalink":"https://nojejesus.github.io/techTube/tags/缓存/"}]},{"title":"多线程并发与线程安全","date":"2019-07-20T04:07:38.000Z","path":"2019/07/20/多线程并发与线程安全/","text":"死锁四个必要条件： 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 例子： [展示代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 一个简单的死锁类 * 当DeadLock类的对象flag==1时（td1），先锁定o1，睡眠500毫秒， * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2，睡眠500毫秒， * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定， * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定， * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。 */@Slf4jpublic class DeadLock implements Runnable &#123; public int flag = 1; //静态对象是类的所有对象共享的 private static Object o1 = new Object(), o2 = new Object(); @Override public void run() &#123; log.info(\"flag: &#123;&#125;\", flag); if (flag == 1) &#123; //锁o1 synchronized (o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //锁o2 synchronized (o2) &#123; log.info(\"1\"); &#125; &#125; &#125; if (flag == 0) &#123; //锁o2 synchronized (o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //锁o1 synchronized (o1) &#123; log.info(\"0\"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; DeadLock td1 = new DeadLock(); DeadLock td2 = new DeadLock(); td1.flag = 1; td2.flag = 0; //td1，td2都处于可执行状态，但是JVM线程调度先先执行哪个线程是不确定的。 //td2的run()可能在td1的run()之前运行。 new Thread(td1).start(); new Thread(td2).start(); &#125;&#125; 避免死锁方法1.加锁顺序，线程要按一定顺序加锁。2.加锁时限，加锁时要限时，超过时限就要放弃对该锁的请求并释放自己占有的锁。如ReentranLock。3.死锁检测，这是个说起来容易做起来难的办法。一般也没人选择这样实现。在实际项目中，如果发生了死锁，往往就要重启项目，这个代价还是非常大的。 Spring与线程安全 Spring Bean: singleton(单例)、prototypeSpring对每个Bean提供了scope属性来表示该Bean之作用域，它是这个Bean的生命周期，singleton对象表示单例对象，在第一次注入时就会被复用到应用结束；prototype类型则在每次注入时都会创建新的对象。 无状态对象由Spring管理的对象其实大多数是无状态对象（不会因为多线程进行线程调度而导致状态被破坏）。包括常用到的dto、vo这些只作为数据实体模型的对象，还有service、dao、controller等等对象。例如每个dao提供的函数，对只是对数据库的crud操作，并且每个数据库的connection都是作为函数的局部变量，用完即关，或者交还连接池。局部变量是在用户栈中，是线程私有的内存区域，所以也不存在线程安全问题。 所以很清楚，Spring对Bean的多线程安全问题并没有做出任何保证或措施，对于每个Bean不存在线程安全问题，根本原因是这些Bean的设计并没有在Bean中声明任何有状态的实例变量或类变量。如果要做有状态设计，那么可以使用ThreadLocal把变量变成线程私有，而如果Bean的实例变量或者类变量需要在多个线程间共享，那就只能使用synchronized、lock、CAS等实现线程同步了。 HashMap与ConcurrentHashMap前者是非线程安全的，后者是线程安全的。前者允许key，value为空，后者则不允许。前者不允许在通过Iterator遍历同时对HashMap修改（例如使用iterator的remove()），而后者是允许的，并且更新后续可见。ConcurrentHashMap是也通过key的哈希值与数组的长度的取模来确定该key在数组中的索引（是不是有点绕），与以往版本不同的是，在Java8里ConcurrentHashMap的实现做了较大调整，取消了segment分段锁而采用CAS和synchronized来保证并发安全，数据结构采用数组+链表/红黑二叉树的方式实现（当链表中的节点个数超过8个时，转换成红黑树的数据结构来存储。synchronized只锁定当前链表或红黑二叉树的首节点），提高了并发性，寻址效率高。(补充一下，1.8HashMap也不再仅仅是数组+链表形式，也有树了) 概念：fast-fail机制即快速失败机制，是java集合（Collection）中的一种错误检测机制。在迭代集合的过程中该集合在结构上发生改变时，就可能发生fast-fail，即抛出ConcurrentModificationException异常。fast-fail机制并不保证在异步修改一定会抛出异常，它只是“尽最大努力”去抛出，所以这种机制一般仅用于检测bug。推荐阅读：http://www.nowamagic.net/librarys/veda/detail/1202 HashMap的存取之美","raw":"---\ntitle: 多线程并发与线程安全\ndate: 2019-07-20 12:07:38\ntags: \n- 多线程\n- 并发\n- 线程安全\ncategories: \n- Java杂谈\n---\n### 死锁\n四个必要条件：\n> - 互斥条件\n> - 请求和保持条件\n> - 不剥夺条件\n> - 环路等待条件\n<!-- more -->\n例子：\n<details>\n<summary><font color=darkred>[展示代码]</font></summary>\n\n```java\n/**\n * 一个简单的死锁类\n * 当DeadLock类的对象flag==1时（td1），先锁定o1，睡眠500毫秒，\n * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2，睡眠500毫秒，\n * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定，\n * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定，\n * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。\n */\n\n@Slf4j\npublic class DeadLock implements Runnable {\n    public int flag = 1;\n    //静态对象是类的所有对象共享的\n    private static Object o1 = new Object(), o2 = new Object();\n\n    @Override\n    public void run() {\n        log.info(\"flag: {}\", flag);\n        if (flag == 1) {\n            //锁o1\n            synchronized (o1) {\n                try {\n                    Thread.sleep(500);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                //锁o2\n                synchronized (o2) {\n                    log.info(\"1\");\n                }\n            }\n        }\n        if (flag == 0) {\n            //锁o2\n            synchronized (o2) {\n                try {\n                    Thread.sleep(500);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                //锁o1\n                synchronized (o1) {\n                    log.info(\"0\");\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        DeadLock td1 = new DeadLock();\n        DeadLock td2 = new DeadLock();\n        td1.flag = 1;\n        td2.flag = 0;\n        //td1，td2都处于可执行状态，但是JVM线程调度先先执行哪个线程是不确定的。\n        //td2的run()可能在td1的run()之前运行。\n        new Thread(td1).start();\n        new Thread(td2).start();\n    }\n\n}\n```\n</details>\n\n### 避免死锁方法\n1.加锁顺序，线程要按一定顺序加锁。\n2.加锁时限，加锁时要限时，超过时限就要放弃对该锁的请求并释放自己占有的锁。如ReentranLock。\n3.死锁检测，这是个说起来容易做起来难的办法。一般也没人选择这样实现。\n在实际项目中，如果发生了死锁，往往就要重启项目，这个代价还是非常大的。\n\n### Spring与线程安全\n- Spring Bean: singleton(单例)、prototype\nSpring对每个Bean提供了scope属性来表示该Bean之作用域，它是这个Bean的生命周期，singleton对象表示单例对象，在第一次注入时就会被复用到应用结束；prototype类型则在每次注入时都会创建新的对象。\n- 无状态对象\n由Spring管理的对象其实大多数是无状态对象（不会因为多线程进行线程调度而导致状态被破坏）。包括常用到的dto、vo这些只作为数据实体模型的对象，还有service、dao、controller等等对象。例如每个dao提供的函数，对只是对数据库的crud操作，并且每个数据库的connection都是作为函数的局部变量，用完即关，或者交还连接池。\n局部变量是在用户栈中，是线程私有的内存区域，所以也不存在线程安全问题。\n\n所以很清楚，Spring对Bean的多线程安全问题并没有做出任何保证或措施，对于每个Bean不存在线程安全问题，根本原因是这些Bean的设计并没有在Bean中声明任何有状态的实例变量或类变量。如果要做有状态设计，那么可以使用ThreadLocal把变量变成线程私有，而如果Bean的实例变量或者类变量需要在多个线程间共享，那就只能使用synchronized、lock、CAS等实现线程同步了。\n\n### HashMap与ConcurrentHashMap\n前者是非线程安全的，后者是线程安全的。\n前者允许key，value为空，后者则不允许。\n前者不允许在通过Iterator遍历同时对HashMap修改（例如使用iterator的remove()），而后者是允许的，并且更新后续可见。\nConcurrentHashMap是也通过key的哈希值与数组的长度的取模来确定该key在数组中的索引（是不是有点绕），与以往版本不同的是，在Java8里ConcurrentHashMap的实现做了较大调整，取消了segment分段锁而采用CAS和synchronized来保证并发安全，数据结构采用数组+链表/红黑二叉树的方式实现（当链表中的节点个数超过8个时，转换成红黑树的数据结构来存储。synchronized只锁定当前链表或红黑二叉树的首节点），提高了并发性，寻址效率高。(补充一下，1.8HashMap也不再仅仅是数组+链表形式，也有树了)\n### 概念：fast-fail机制\n即快速失败机制，是java集合（Collection）中的一种错误检测机制。在迭代集合的过程中该集合在结构上发生改变时，就可能发生fast-fail，即抛出ConcurrentModificationException异常。fast-fail机制并不保证在异步修改一定会抛出异常，它只是“尽最大努力”去抛出，所以这种机制一般仅用于检测bug。\n推荐阅读：http://www.nowamagic.net/librarys/veda/detail/1202 HashMap的存取之美","content":"<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>四个必要条件：</p>\n<blockquote>\n<ul>\n<li>互斥条件</li>\n<li>请求和保持条件</li>\n<li>不剥夺条件</li>\n<li>环路等待条件</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>例子：</p>\n<details>\n<summary><font color=\"darkred\">[展示代码]</font></summary>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一个简单的死锁类</span></span><br><span class=\"line\"><span class=\"comment\"> * 当DeadLock类的对象flag==1时（td1），先锁定o1，睡眠500毫秒，</span></span><br><span class=\"line\"><span class=\"comment\"> * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2，睡眠500毫秒，</span></span><br><span class=\"line\"><span class=\"comment\"> * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定，</span></span><br><span class=\"line\"><span class=\"comment\"> * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定，</span></span><br><span class=\"line\"><span class=\"comment\"> * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//静态对象是类的所有对象共享的</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object o1 = <span class=\"keyword\">new</span> Object(), o2 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"flag: &#123;&#125;\"</span>, flag);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//锁o1</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (o1) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//锁o2</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (o2) &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//锁o2</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (o2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//锁o1</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (o1) &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        DeadLock td1 = <span class=\"keyword\">new</span> DeadLock();</span><br><span class=\"line\">        DeadLock td2 = <span class=\"keyword\">new</span> DeadLock();</span><br><span class=\"line\">        td1.flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        td2.flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//td1，td2都处于可执行状态，但是JVM线程调度先先执行哪个线程是不确定的。</span></span><br><span class=\"line\">        <span class=\"comment\">//td2的run()可能在td1的run()之前运行。</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(td1).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(td2).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<h3 id=\"避免死锁方法\"><a href=\"#避免死锁方法\" class=\"headerlink\" title=\"避免死锁方法\"></a>避免死锁方法</h3><p>1.加锁顺序，线程要按一定顺序加锁。<br>2.加锁时限，加锁时要限时，超过时限就要放弃对该锁的请求并释放自己占有的锁。如ReentranLock。<br>3.死锁检测，这是个说起来容易做起来难的办法。一般也没人选择这样实现。<br>在实际项目中，如果发生了死锁，往往就要重启项目，这个代价还是非常大的。</p>\n<h3 id=\"Spring与线程安全\"><a href=\"#Spring与线程安全\" class=\"headerlink\" title=\"Spring与线程安全\"></a>Spring与线程安全</h3><ul>\n<li>Spring Bean: singleton(单例)、prototype<br>Spring对每个Bean提供了scope属性来表示该Bean之作用域，它是这个Bean的生命周期，singleton对象表示单例对象，在第一次注入时就会被复用到应用结束；prototype类型则在每次注入时都会创建新的对象。</li>\n<li>无状态对象<br>由Spring管理的对象其实大多数是无状态对象（不会因为多线程进行线程调度而导致状态被破坏）。包括常用到的dto、vo这些只作为数据实体模型的对象，还有service、dao、controller等等对象。例如每个dao提供的函数，对只是对数据库的crud操作，并且每个数据库的connection都是作为函数的局部变量，用完即关，或者交还连接池。<br>局部变量是在用户栈中，是线程私有的内存区域，所以也不存在线程安全问题。</li>\n</ul>\n<p>所以很清楚，Spring对Bean的多线程安全问题并没有做出任何保证或措施，对于每个Bean不存在线程安全问题，根本原因是这些Bean的设计并没有在Bean中声明任何有状态的实例变量或类变量。如果要做有状态设计，那么可以使用ThreadLocal把变量变成线程私有，而如果Bean的实例变量或者类变量需要在多个线程间共享，那就只能使用synchronized、lock、CAS等实现线程同步了。</p>\n<h3 id=\"HashMap与ConcurrentHashMap\"><a href=\"#HashMap与ConcurrentHashMap\" class=\"headerlink\" title=\"HashMap与ConcurrentHashMap\"></a>HashMap与ConcurrentHashMap</h3><p>前者是非线程安全的，后者是线程安全的。<br>前者允许key，value为空，后者则不允许。<br>前者不允许在通过Iterator遍历同时对HashMap修改（例如使用iterator的remove()），而后者是允许的，并且更新后续可见。<br>ConcurrentHashMap是也通过key的哈希值与数组的长度的取模来确定该key在数组中的索引（是不是有点绕），与以往版本不同的是，在Java8里ConcurrentHashMap的实现做了较大调整，取消了segment分段锁而采用CAS和synchronized来保证并发安全，数据结构采用数组+链表/红黑二叉树的方式实现（当链表中的节点个数超过8个时，转换成红黑树的数据结构来存储。synchronized只锁定当前链表或红黑二叉树的首节点），提高了并发性，寻址效率高。(补充一下，1.8HashMap也不再仅仅是数组+链表形式，也有树了)</p>\n<h3 id=\"概念：fast-fail机制\"><a href=\"#概念：fast-fail机制\" class=\"headerlink\" title=\"概念：fast-fail机制\"></a>概念：fast-fail机制</h3><p>即快速失败机制，是java集合（Collection）中的一种错误检测机制。在迭代集合的过程中该集合在结构上发生改变时，就可能发生fast-fail，即抛出ConcurrentModificationException异常。fast-fail机制并不保证在异步修改一定会抛出异常，它只是“尽最大努力”去抛出，所以这种机制一般仅用于检测bug。<br>推荐阅读：<a href=\"http://www.nowamagic.net/librarys/veda/detail/1202\" target=\"_blank\" rel=\"noopener\">http://www.nowamagic.net/librarys/veda/detail/1202</a> HashMap的存取之美</p>\n","slug":"多线程并发与线程安全","updated":"2019-07-21T00:19:44.840Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/20/多线程并发与线程安全/","excerpt":"死锁四个必要条件： 互斥条件 请求和保持条件 不剥夺条件 环路等待条件","categories":[{"name":"Java杂谈","slug":"Java杂谈","permalink":"https://nojejesus.github.io/techTube/categories/Java杂谈/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://nojejesus.github.io/techTube/tags/并发/"},{"name":"多线程","slug":"多线程","permalink":"https://nojejesus.github.io/techTube/tags/多线程/"},{"name":"线程安全","slug":"线程安全","permalink":"https://nojejesus.github.io/techTube/tags/线程安全/"}]},{"title":"CountDownLatch","date":"2019-07-20T03:59:55.000Z","path":"2019/07/20/CountDownLatch/","text":"待添加","raw":"---\ntitle: CountDownLatch\ndate: 2019-07-20 11:59:55\ntags:\n- CountDownLatch\n- 并发\ncategories: \n- Java杂谈\n---\n\n##### 待添加\n<!-- more -->","content":"<h5 id=\"待添加\"><a href=\"#待添加\" class=\"headerlink\" title=\"待添加\"></a>待添加</h5><a id=\"more\"></a>","slug":"CountDownLatch","updated":"2019-07-20T15:00:10.370Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/20/CountDownLatch/","excerpt":"待添加","categories":[{"name":"Java杂谈","slug":"Java杂谈","permalink":"https://nojejesus.github.io/techTube/categories/Java杂谈/"}],"tags":[{"name":"CountDownLatch","slug":"CountDownLatch","permalink":"https://nojejesus.github.io/techTube/tags/CountDownLatch/"},{"name":"并发","slug":"并发","permalink":"https://nojejesus.github.io/techTube/tags/并发/"}]},{"title":"Spring Cloud","date":"2019-07-19T15:17:40.000Z","path":"2019/07/19/Spring-Cloud/","text":"待添加 待添加","raw":"---\ntitle: Spring Cloud\ndate: 2019-07-19 23:17:40\ntags: #标签\n- Spring Cloud\n- 框架\ncategories: #分类\n- Spring框架\n---\n\n### 待添加\n\n<div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/lakers1.jpg\" />\n</div>\n\n<!-- more -->\n\n-------------------------------------------------------------------\n\n### 待添加\n\n<div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/rocket1.jpg\" />\n</div>\n\n","content":"<h3 id=\"待添加\"><a href=\"#待添加\" class=\"headerlink\" title=\"待添加\"></a>待添加</h3><div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/lakers1.jpg\">\n</div>\n\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"待添加-1\"><a href=\"#待添加-1\" class=\"headerlink\" title=\"待添加\"></a>待添加</h3><div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/rocket1.jpg\">\n</div>\n\n","slug":"Spring-Cloud","updated":"2019-07-20T01:06:40.644Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/Spring-Cloud/","excerpt":"待添加","categories":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://nojejesus.github.io/techTube/tags/框架/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://nojejesus.github.io/techTube/tags/Spring-Cloud/"}]},{"title":"Spring Boot","date":"2019-07-19T11:10:28.000Z","path":"2019/07/19/Spring-Boot/","text":"待添加","raw":"---\ntitle: Spring Boot\ndate: 2019-07-19 19:10:28\ntags: #标签\n- Spring Boot\n- 框架\ncategories: #分类\n- Spring框架\n---\n\n##### 待添加\n\n<!-- more -->\n\n","content":"<h5 id=\"待添加\"><a href=\"#待添加\" class=\"headerlink\" title=\"待添加\"></a>待添加</h5><a id=\"more\"></a>\n\n","slug":"Spring-Boot","updated":"2019-07-20T02:01:46.632Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/Spring-Boot/","excerpt":"待添加","categories":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://nojejesus.github.io/techTube/tags/Spring-Boot/"},{"name":"框架","slug":"框架","permalink":"https://nojejesus.github.io/techTube/tags/框架/"}]},{"title":"线程池","date":"2019-07-19T07:31:49.000Z","path":"2019/07/19/线程池/","text":"ThreadPoolExecutorgraph LR; RUNNING--\"shutdown()\"-->SHUTDOWN; RUNNING--\"shutdownNow()\"-->STOP; SHUTDOWN--\"阻塞队列为空，线程池中的工作数量为0\"-->TIDYING; STOP--线程池中的工作线程数量为0-->TIDYING; TIDYING--\"terminated()\"-->TERMINATED; 监控线程池 getTaskCount(): 线程池已执行和未执行的任务总数 getCompletedTaskCount(): 已完成的任务数量 getPoolSize(): 线程池当前的线程数量 getActiveCount(): 当前线程池中正在执行任务的线程总数 线程池的合理配置 cpu密集型任务，就需要尽量压榨CPU，参考值可以设置为NCPU+1IO密集型任务，参考值可以设置为2*NCPU 这只是参考值，并不代表随时随地拿线程池来用，要根据实际场景来分析选择以及参数的配置。例如，在开发企业级权限系统中，部门数的生成过程尝试使用线程池，结果是反而变慢，因为线程池里面的任务都很小（小到任务生成的时间和调度管理时间都很接近），这就造成资源浪费了。 关于用到newCachedThreadPool线程池可能会遇到的问题newCachedThreadPool的源码 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 可以看到它允许的线程数为Integer.MAX_VALUE，这代表可以无限大，因为线程数可以这么多，所以会可能导致OOM问题，要解决这个问题，根本上要自己定义个方法，给线程数设置一个合理的上限，例如： 1return new ThreadPoolExecutor(0,1024，60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());","raw":"---\ntitle: 线程池\ndate: 2019-07-19 15:31:49\ntags: #标签\n- 线程池\ncategories: #分类\n- Java杂谈\n---\n### ThreadPoolExecutor\n\n```mermaid\ngraph LR;\n    RUNNING--\"shutdown()\"-->SHUTDOWN;\n    RUNNING--\"shutdownNow()\"-->STOP;\n    SHUTDOWN--\"阻塞队列为空，线程池中的工作数量为0\"-->TIDYING;\n    STOP--线程池中的工作线程数量为0-->TIDYING;\n    TIDYING--\"terminated()\"-->TERMINATED;\n```\n\n+ 监控线程池\n- getTaskCount(): 线程池已执行和未执行的任务总数\n- getCompletedTaskCount(): 已完成的任务数量\n- getPoolSize(): 线程池当前的线程数量\n- getActiveCount(): 当前线程池中正在执行任务的线程总数\n\n<!-- more -->\n\n##### 线程池的合理配置\n>>cpu密集型任务，就需要尽量压榨CPU，参考值可以设置为NCPU+1\n>>IO密集型任务，参考值可以设置为2*NCPU\n\n>>这只是参考值，并不代表随时随地拿线程池来用，要根据实际场景来分析选择以及参数的配置。例如，在开发企业级权限系统中，部门数的生成过程尝试使用线程池，结果是反而变慢，因为线程池里面的任务都很小（小到任务生成的时间和调度管理时间都很接近），这就造成资源浪费了。\n\n##### 关于用到newCachedThreadPool线程池可能会遇到的问题\n\nnewCachedThreadPool的源码\n```java\npublic static ExecutorService newCachedThreadPool() {\n   return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                 60L, TimeUnit.SECONDS,\n                                 new SynchronousQueue<Runnable>());\n}\n```\n可以看到它允许的线程数为Integer.MAX_VALUE，这代表可以无限大，因为线程数可以这么多，所以会可能导致OOM问题，要解决这个问题，根本上要自己定义个方法，给线程数设置一个合理的上限，例如：\n```java\nreturn new ThreadPoolExecutor(0,1024，60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());\n```\n\n","content":"<h3 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h3><pre class=\"mermaid\">graph LR;\n    RUNNING--\"shutdown()\"-->SHUTDOWN;\n    RUNNING--\"shutdownNow()\"-->STOP;\n    SHUTDOWN--\"阻塞队列为空，线程池中的工作数量为0\"-->TIDYING;\n    STOP--线程池中的工作线程数量为0-->TIDYING;\n    TIDYING--\"terminated()\"-->TERMINATED;</pre>\n\n<ul>\n<li>监控线程池</li>\n</ul>\n<ul>\n<li>getTaskCount(): 线程池已执行和未执行的任务总数</li>\n<li>getCompletedTaskCount(): 已完成的任务数量</li>\n<li>getPoolSize(): 线程池当前的线程数量</li>\n<li>getActiveCount(): 当前线程池中正在执行任务的线程总数</li>\n</ul>\n<a id=\"more\"></a>\n\n<h5 id=\"线程池的合理配置\"><a href=\"#线程池的合理配置\" class=\"headerlink\" title=\"线程池的合理配置\"></a>线程池的合理配置</h5><blockquote>\n<blockquote>\n<p>cpu密集型任务，就需要尽量压榨CPU，参考值可以设置为NCPU+1<br>IO密集型任务，参考值可以设置为2*NCPU</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>这只是参考值，并不代表随时随地拿线程池来用，要根据实际场景来分析选择以及参数的配置。例如，在开发企业级权限系统中，部门数的生成过程尝试使用线程池，结果是反而变慢，因为线程池里面的任务都很小（小到任务生成的时间和调度管理时间都很接近），这就造成资源浪费了。</p>\n</blockquote>\n</blockquote>\n<h5 id=\"关于用到newCachedThreadPool线程池可能会遇到的问题\"><a href=\"#关于用到newCachedThreadPool线程池可能会遇到的问题\" class=\"headerlink\" title=\"关于用到newCachedThreadPool线程池可能会遇到的问题\"></a>关于用到newCachedThreadPool线程池可能会遇到的问题</h5><p>newCachedThreadPool的源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                 <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                 <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到它允许的线程数为Integer.MAX_VALUE，这代表可以无限大，因为线程数可以这么多，所以会可能导致OOM问题，要解决这个问题，根本上要自己定义个方法，给线程数设置一个合理的上限，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>,<span class=\"number\">1024</span>，<span class=\"number\">60L</span>, TimeUnit.SECONDS, <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>\n\n","slug":"线程池","updated":"2019-07-20T04:11:38.435Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/线程池/","excerpt":"ThreadPoolExecutorgraph LR; RUNNING--\"shutdown()\"-->SHUTDOWN; RUNNING--\"shutdownNow()\"-->STOP; SHUTDOWN--\"阻塞队列为空，线程池中的工作数量为0\"-->TIDYING; STOP--线程池中的工作线程数量为0-->TIDYING; TIDYING--\"terminated()\"-->TERMINATED; 监控线程池 getTaskCount(): 线程池已执行和未执行的任务总数 getCompletedTaskCount(): 已完成的任务数量 getPoolSize(): 线程池当前的线程数量 getActiveCount(): 当前线程池中正在执行任务的线程总数","categories":[{"name":"Java杂谈","slug":"Java杂谈","permalink":"https://nojejesus.github.io/techTube/categories/Java杂谈/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"https://nojejesus.github.io/techTube/tags/线程池/"}]},{"title":"Spring","date":"2019-07-19T05:10:53.000Z","path":"2019/07/19/Spring/","text":"Spring源码分析blablabla","raw":"---\nlayout: _posts\ntitle: Spring\ndate: 2019-07-19 13:10:53\ntags: #标签\n- Spring\n- 框架\ncategories: #分类\n- Spring框架\n---\n##### Spring源码分析\n\n##### blablabla\n\n<!-- more -->","content":"<h5 id=\"Spring源码分析\"><a href=\"#Spring源码分析\" class=\"headerlink\" title=\"Spring源码分析\"></a>Spring源码分析</h5><h5 id=\"blablabla\"><a href=\"#blablabla\" class=\"headerlink\" title=\"blablabla\"></a>blablabla</h5><a id=\"more\"></a>","slug":"Spring","updated":"2019-07-20T04:11:58.230Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/Spring/","excerpt":"Spring源码分析blablabla","categories":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://nojejesus.github.io/techTube/tags/框架/"},{"name":"Spring","slug":"Spring","permalink":"https://nojejesus.github.io/techTube/tags/Spring/"}]},{"title":"朝花夕拾","date":"2019-07-19T01:03:37.705Z","path":"2019/07/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":"---\ntitle: 朝花夕拾\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","slug":"hello-world","updated":"2019-07-19T20:03:29.006Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","categories":[],"tags":[]}]}