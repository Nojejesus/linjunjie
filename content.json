{"meta":{"title":"Talk is cheap, show you my code.","subtitle":"千里之行，始于足下","description":"苟利国家生死以，岂因祸福避趋之","author":"Junjie Lin","url":"https://nojejesus.github.io/techTube","root":"/techTube/"},"pages":[{},{},{}],"posts":[{"title":"SpringBoot开发常用技术整合","date":"2019-08-03T03:06:37.000Z","path":"2019/08/03/SpringBoot开发常用技术整合/","text":"用.yml配置mysql连接删除resource下文件application.properties，创建文件application.yml 123456789server: port: 8080spring: datasource: name: toufu url: jdbc:mysql://39.108.73.179:3306/test1?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true username: rootxxx password: rootpasswordxxx @JsonIgnore、@JsonInclude、@JsonFormat @JsonIgnore 在Json序列化时，java bean中被此注解标记的属性会被忽略掉，序列化和反序列化都会受此影响。一般标示在属性和方法上，在返回的json数据中就不会包含该属性。 @JsonInclude 控制java pojo对象在序列化成json时，哪些情况才将被转换，例如：@JsonInclude(JsonInclude.Include.NON_NULL) 添加在类上，则当此对象为空或拥有的空字段，不会返回json数据；添加在属性（字段）上，当该属性值为null，返回的json不会包含该属性。 @JsonFormat Date和String的相互转化。例如：12@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\") private Date operate_time; 将Date转化String输出 “operate_time”: “2019-08-03 04:00:03” SpringBoot开发环境热部署使用devtools进行热部署 实现页面热部署（即页面修改后可以立即生效，实现方法例如：在application.properties文件中配置spring.thymeleaf.cache=false或spring.freemaker.cache=false即可）。 类文件热部署（类文件修改后不会立即生效，但devtools会监听classpath下的文件变动，并且保存时立即重启，注意的是，由于采用虚拟机机制，只加载在开发class，不重新加载第三方jar包，该重启是很快的）。更多配置：1234567891011#热部署生效spring.devtools.restart.enabled=true#设置重启的目录，需要restart的文件spring.devtools.restart.addtional-paths=src/main/java#为mybatis设置，生产环境可删除restart.include.mapper=/mapper-[\\\\w-\\\\.]+jarrestart.include.pageHelper=/pageHelper-[\\\\w-\\\\.]+jar#排除不需要restart的文件spring.devtools.restart.exclude=static/**,public/**#classpath目录下的WEB-INFO文件夹内容修改不重启spring.devtools.restart.exclude=WEB-INFO/** 添加依赖: 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-devtools&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 注意的点：在intelij idea热部署如果不生效，解决办法 “Setting&gt;Build,Execution,Deployment&gt;Compiler”，勾选“Build project automatically” “Ctrl+Shift+Alt+/” 调出面板“Maintenance，Resgistry…”， 勾选“compiler.automake.allow.when.app.running” 资源文件属性配置样例 pom引入依赖： 12345&lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-configuration-processor&lt;/artifactId&gt; &lt;optional&gt;true&lt;/optional&gt;&lt;/dependency&gt; 配置文件application.yml: 1234567891011121314151617181920212223server: port: 8080spring: datasource: name: toufu url: jdbc:mysql://39.108.73.179:3306/test1?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true username: rootxxx password: rootpasswordxxx # devtools开发环境热部署 devtools: restart: enabled: true additional-paths: src/main/java# 资源文件属性配置com: myapp: opensource: name: toufuStore website: www.toufuStore.com language: java 添加名为Resource的类，注意它的注解： [展示代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546package com.myapp.pojo;import org.springframework.boot.context.properties.ConfigurationProperties;import org.springframework.context.annotation.Configuration;import org.springframework.context.annotation.PropertySource;@Configuration@ConfigurationProperties(prefix = \"com.myapp.opensource\")@PropertySource(value = \"classpath:application.yml\")public class Resource &#123; private String name; private String website; private String language; public String getName() &#123; return name; &#125; public void setName(String name) &#123; this.name = name; &#125; public String getWebsite() &#123; return website; &#125; public void setWebsite(String website) &#123; this.website = website; &#125; public String getLanguage() &#123; return language; &#125; public void setLanguage(String language) &#123; this.language = language; &#125; @Override public String toString() &#123; return name + \" | \" + website + \" | \" + language; &#125;&#125; 控制层 123456789101112131415161718192021222324252627282930package com.myapp.controller;import com.myapp.pojo.Resource;import org.springframework.beans.BeanUtils;import org.springframework.beans.factory.annotation.Autowired;import org.springframework.web.bind.annotation.RequestMapping;import org.springframework.web.bind.annotation.RestController;import java.util.Date;@RestControllerpublic class Head &#123; @Autowired private Resource resource; @RequestMapping(\"/get_resource\") public Object getResource() &#123;//① return resource.toString();//② Resource resourceBean = new Resource();// return resourceBean.toString();//③ Resource target = new Resource();// BeanUtils.copyProperties(resource, target);// return target.toString(); &#125;&#125; 访问”http://localhost:8080/get_resource&quot;返回结果 12//①toufuStore | www.toufuStore.com | java 12//②null | null | null 12//③toufuStore | www.toufuStore.com | java","raw":"---\ntitle: SpringBoot开发常用技术整合\ndate: 2019-08-03 11:06:37\ntags:\ncategories:\n- Spring Boot\n---\n## 用.yml配置mysql连接\n删除resource下文件application.properties，创建文件application.yml\n```yml\nserver:\n  port: 8080\n\nspring:\n  datasource:\n    name: toufu\n    url: jdbc:mysql://39.108.73.179:3306/test1?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true\n    username: rootxxx\n    password: rootpasswordxxx\n```\n\n<!-- more -->\n\n## @JsonIgnore、@JsonInclude、@JsonFormat\n+ @JsonIgnore 在Json序列化时，java bean中被此注解标记的属性会被忽略掉，序列化和反序列化都会受此影响。\n一般标示在属性和方法上，在返回的json数据中就不会包含该属性。\n+ @JsonInclude 控制java pojo对象在序列化成json时，哪些情况才将被转换，例如：\n@JsonInclude(JsonInclude.Include.NON_NULL) 添加在类上，则当此对象为空或拥有的空字段，不会返回json数据；\n添加在属性（字段）上，当该属性值为null，返回的json不会包含该属性。\n+ @JsonFormat Date和String的相互转化。\n例如：\n```java\n@JsonFormat(pattern = \"yyyy-MM-dd HH:mm:ss\")\n    private Date operate_time;\n```\n将Date转化String输出 \"operate_time\": \"2019-08-03 04:00:03\"\n\n## SpringBoot开发环境热部署\n### 使用devtools进行热部署\n+ 实现页面热部署（即页面修改后可以立即生效，实现方法例如：在application.properties文件中配置spring.thymeleaf.cache=false或spring.freemaker.cache=false即可）。\n+ 类文件热部署（类文件修改后不会立即生效，但devtools会监听classpath下的文件变动，并且保存时立即重启，注意的是，由于采用虚拟机机制，只加载在开发class，不重新加载第三方jar包，该重启是很快的）。\n更多配置：\n```yml\n#热部署生效\nspring.devtools.restart.enabled=true\n#设置重启的目录，需要restart的文件\nspring.devtools.restart.addtional-paths=src/main/java\n#为mybatis设置，生产环境可删除\nrestart.include.mapper=/mapper-[\\\\w-\\\\.]+jar\nrestart.include.pageHelper=/pageHelper-[\\\\w-\\\\.]+jar\n#排除不需要restart的文件\nspring.devtools.restart.exclude=static/**,public/**\n#classpath目录下的WEB-INFO文件夹内容修改不重启\nspring.devtools.restart.exclude=WEB-INFO/**\n```\n\n添加依赖:\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-devtools</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n### 注意的点：在intelij idea热部署如果不生效，解决办法  \n1. “Setting>Build,Execution,Deployment>Compiler”，勾选“Build project automatically”\n2. “Ctrl+Shift+Alt+/” 调出面板“Maintenance，Resgistry...”， 勾选“compiler.automake.allow.when.app.running”\n\n## 资源文件属性配置样例\n1. pom引入依赖：\n```xml\n<dependency>\n    <groupId>org.springframework.boot</groupId>\n    <artifactId>spring-boot-configuration-processor</artifactId>\n    <optional>true</optional>\n</dependency>\n```\n\n2. 配置文件application.yml:\n```yml\nserver:\n  port: 8080\n\nspring:\n  datasource:\n    name: toufu\n    url: jdbc:mysql://39.108.73.179:3306/test1?useUnicode=true&characterEncoding=UTF-8&allowMultiQueries=true\n    username: rootxxx\n    password: rootpasswordxxx\n\n  # devtools开发环境热部署\n  devtools:\n    restart:\n      enabled: true\n      additional-paths: src/main/java\n\n# 资源文件属性配置\ncom:\n  myapp:\n    opensource:\n      name: toufuStore\n      website: www.toufuStore.com\n      language: java\n```\n\n3. 添加名为Resource的类，注意它的注解：\n\n    <details>\n    <summary><font color=darkred>[展示代码]</font></summary>\n\n    ```java\n        package com.myapp.pojo;\n\n        import org.springframework.boot.context.properties.ConfigurationProperties;\n        import org.springframework.context.annotation.Configuration;\n        import org.springframework.context.annotation.PropertySource;\n\n        @Configuration\n        @ConfigurationProperties(prefix = \"com.myapp.opensource\")\n        @PropertySource(value = \"classpath:application.yml\")\n        public class Resource {\n\n            private String name;\n\n            private String website;\n\n            private String language;\n\n            public String getName() {\n                return name;\n            }\n\n            public void setName(String name) {\n                this.name = name;\n            }\n\n            public String getWebsite() {\n                return website;\n            }\n\n            public void setWebsite(String website) {\n                this.website = website;\n            }\n\n            public String getLanguage() {\n                return language;\n            }\n\n            public void setLanguage(String language) {\n                this.language = language;\n            }\n\n            @Override\n            public String toString() {\n                return name + \" | \" + website + \" | \" + language;\n            }\n        }\n    ```\n    </details>  \n\n4. 控制层\n```java\npackage com.myapp.controller;\n\nimport com.myapp.pojo.Resource;\nimport org.springframework.beans.BeanUtils;\nimport org.springframework.beans.factory.annotation.Autowired;\nimport org.springframework.web.bind.annotation.RequestMapping;\nimport org.springframework.web.bind.annotation.RestController;\n\nimport java.util.Date;\n\n@RestController\npublic class Head {\n\n    @Autowired\n    private Resource resource;\n\n    @RequestMapping(\"/get_resource\")\n    public Object getResource() {\n\n//①        return resource.toString();\n\n//②        Resource resourceBean = new Resource();\n//        return resourceBean.toString();\n\n//③       Resource target = new Resource();\n//        BeanUtils.copyProperties(resource, target);\n//        return target.toString();\n    }\n\n}\n\n```\n\n5. 访问\"http://localhost:8080/get_resource\"返回结果  \n```java\n//①\ntoufuStore | www.toufuStore.com | java\n```\n```java\n//②\nnull | null | null\n```\n```java\n//③\ntoufuStore | www.toufuStore.com | java\n```\n","content":"<h2 id=\"用-yml配置mysql连接\"><a href=\"#用-yml配置mysql连接\" class=\"headerlink\" title=\"用.yml配置mysql连接\"></a>用.yml配置mysql连接</h2><p>删除resource下文件application.properties，创建文件application.yml</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  datasource:</span></span><br><span class=\"line\"><span class=\"attr\">    name:</span> <span class=\"string\">toufu</span></span><br><span class=\"line\"><span class=\"attr\">    url:</span> <span class=\"attr\">jdbc:mysql://39.108.73.179:3306/test1?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true</span></span><br><span class=\"line\"><span class=\"attr\">    username:</span> <span class=\"string\">rootxxx</span></span><br><span class=\"line\"><span class=\"attr\">    password:</span> <span class=\"string\">rootpasswordxxx</span></span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n\n<h2 id=\"JsonIgnore、-JsonInclude、-JsonFormat\"><a href=\"#JsonIgnore、-JsonInclude、-JsonFormat\" class=\"headerlink\" title=\"@JsonIgnore、@JsonInclude、@JsonFormat\"></a>@JsonIgnore、@JsonInclude、@JsonFormat</h2><ul>\n<li>@JsonIgnore 在Json序列化时，java bean中被此注解标记的属性会被忽略掉，序列化和反序列化都会受此影响。<br>一般标示在属性和方法上，在返回的json数据中就不会包含该属性。</li>\n<li>@JsonInclude 控制java pojo对象在序列化成json时，哪些情况才将被转换，例如：<br>@JsonInclude(JsonInclude.Include.NON_NULL) 添加在类上，则当此对象为空或拥有的空字段，不会返回json数据；<br>添加在属性（字段）上，当该属性值为null，返回的json不会包含该属性。</li>\n<li>@JsonFormat Date和String的相互转化。<br>例如：<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@JsonFormat</span>(pattern = <span class=\"string\">\"yyyy-MM-dd HH:mm:ss\"</span>)</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Date operate_time;</span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>将Date转化String输出 “operate_time”: “2019-08-03 04:00:03”</p>\n<h2 id=\"SpringBoot开发环境热部署\"><a href=\"#SpringBoot开发环境热部署\" class=\"headerlink\" title=\"SpringBoot开发环境热部署\"></a>SpringBoot开发环境热部署</h2><h3 id=\"使用devtools进行热部署\"><a href=\"#使用devtools进行热部署\" class=\"headerlink\" title=\"使用devtools进行热部署\"></a>使用devtools进行热部署</h3><ul>\n<li>实现页面热部署（即页面修改后可以立即生效，实现方法例如：在application.properties文件中配置spring.thymeleaf.cache=false或spring.freemaker.cache=false即可）。</li>\n<li>类文件热部署（类文件修改后不会立即生效，但devtools会监听classpath下的文件变动，并且保存时立即重启，注意的是，由于采用虚拟机机制，只加载在开发class，不重新加载第三方jar包，该重启是很快的）。<br>更多配置：<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">#热部署生效</span></span><br><span class=\"line\"><span class=\"string\">spring.devtools.restart.enabled=true</span></span><br><span class=\"line\"><span class=\"comment\">#设置重启的目录，需要restart的文件</span></span><br><span class=\"line\"><span class=\"string\">spring.devtools.restart.addtional-paths=src/main/java</span></span><br><span class=\"line\"><span class=\"comment\">#为mybatis设置，生产环境可删除</span></span><br><span class=\"line\"><span class=\"string\">restart.include.mapper=/mapper-[\\\\w-\\\\.]+jar</span></span><br><span class=\"line\"><span class=\"string\">restart.include.pageHelper=/pageHelper-[\\\\w-\\\\.]+jar</span></span><br><span class=\"line\"><span class=\"comment\">#排除不需要restart的文件</span></span><br><span class=\"line\"><span class=\"string\">spring.devtools.restart.exclude=static/**,public/**</span></span><br><span class=\"line\"><span class=\"comment\">#classpath目录下的WEB-INFO文件夹内容修改不重启</span></span><br><span class=\"line\"><span class=\"string\">spring.devtools.restart.exclude=WEB-INFO/**</span></span><br></pre></td></tr></table></figure>\n\n</li>\n</ul>\n<p>添加依赖:</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-devtools<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注意的点：在intelij-idea热部署如果不生效，解决办法\"><a href=\"#注意的点：在intelij-idea热部署如果不生效，解决办法\" class=\"headerlink\" title=\"注意的点：在intelij idea热部署如果不生效，解决办法\"></a>注意的点：在intelij idea热部署如果不生效，解决办法</h3><ol>\n<li>“Setting&gt;Build,Execution,Deployment&gt;Compiler”，勾选“Build project automatically”</li>\n<li>“Ctrl+Shift+Alt+/” 调出面板“Maintenance，Resgistry…”， 勾选“compiler.automake.allow.when.app.running”</li>\n</ol>\n<h2 id=\"资源文件属性配置样例\"><a href=\"#资源文件属性配置样例\" class=\"headerlink\" title=\"资源文件属性配置样例\"></a>资源文件属性配置样例</h2><ol>\n<li><p>pom引入依赖：</p>\n<figure class=\"highlight xml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"tag\">&lt;<span class=\"name\">dependency</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">groupId</span>&gt;</span>org.springframework.boot<span class=\"tag\">&lt;/<span class=\"name\">groupId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class=\"tag\">&lt;/<span class=\"name\">artifactId</span>&gt;</span></span><br><span class=\"line\">    <span class=\"tag\">&lt;<span class=\"name\">optional</span>&gt;</span>true<span class=\"tag\">&lt;/<span class=\"name\">optional</span>&gt;</span></span><br><span class=\"line\"><span class=\"tag\">&lt;/<span class=\"name\">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>配置文件application.yml:</p>\n<figure class=\"highlight yml\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"attr\">server:</span></span><br><span class=\"line\"><span class=\"attr\">  port:</span> <span class=\"number\">8080</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"attr\">spring:</span></span><br><span class=\"line\"><span class=\"attr\">  datasource:</span></span><br><span class=\"line\"><span class=\"attr\">    name:</span> <span class=\"string\">toufu</span></span><br><span class=\"line\"><span class=\"attr\">    url:</span> <span class=\"attr\">jdbc:mysql://39.108.73.179:3306/test1?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true</span></span><br><span class=\"line\"><span class=\"attr\">    username:</span> <span class=\"string\">rootxxx</span></span><br><span class=\"line\"><span class=\"attr\">    password:</span> <span class=\"string\">rootpasswordxxx</span></span><br><span class=\"line\"></span><br><span class=\"line\">  <span class=\"comment\"># devtools开发环境热部署</span></span><br><span class=\"line\"><span class=\"attr\">  devtools:</span></span><br><span class=\"line\"><span class=\"attr\">    restart:</span></span><br><span class=\"line\"><span class=\"attr\">      enabled:</span> <span class=\"literal\">true</span></span><br><span class=\"line\"><span class=\"attr\">      additional-paths:</span> <span class=\"string\">src/main/java</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\"># 资源文件属性配置</span></span><br><span class=\"line\"><span class=\"attr\">com:</span></span><br><span class=\"line\"><span class=\"attr\">  myapp:</span></span><br><span class=\"line\"><span class=\"attr\">    opensource:</span></span><br><span class=\"line\"><span class=\"attr\">      name:</span> <span class=\"string\">toufuStore</span></span><br><span class=\"line\"><span class=\"attr\">      website:</span> <span class=\"string\">www.toufuStore.com</span></span><br><span class=\"line\"><span class=\"attr\">      language:</span> <span class=\"string\">java</span></span><br></pre></td></tr></table></figure>\n</li>\n<li><p>添加名为Resource的类，注意它的注解：</p>\n <details>\n <summary><font color=\"darkred\">[展示代码]</font></summary>\n\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.myapp.pojo;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.boot.context.properties.ConfigurationProperties;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.Configuration;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.context.annotation.PropertySource;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Configuration</span></span><br><span class=\"line\"><span class=\"meta\">@ConfigurationProperties</span>(prefix = <span class=\"string\">\"com.myapp.opensource\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@PropertySource</span>(value = <span class=\"string\">\"classpath:application.yml\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Resource</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String website;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String language;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.name = name;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getWebsite</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> website;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWebsite</span><span class=\"params\">(String website)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.website = website;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getLanguage</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> language;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setLanguage</span><span class=\"params\">(String language)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.language = language;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> name + <span class=\"string\">\" | \"</span> + website + <span class=\"string\">\" | \"</span> + language;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n </details>  \n</li>\n<li><p>控制层</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.myapp.controller;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.myapp.pojo.Resource;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.BeanUtils;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.beans.factory.annotation.Autowired;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RequestMapping;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.bind.annotation.RestController;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Date;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@RestController</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Head</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Resource resource;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"/get_resource\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">getResource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//①        return resource.toString();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//②        Resource resourceBean = new Resource();</span></span><br><span class=\"line\"><span class=\"comment\">//        return resourceBean.toString();</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//③       Resource target = new Resource();</span></span><br><span class=\"line\"><span class=\"comment\">//        BeanUtils.copyProperties(resource, target);</span></span><br><span class=\"line\"><span class=\"comment\">//        return target.toString();</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>访问”<a href=\"http://localhost:8080/get_resource&quot;返回结果\" target=\"_blank\" rel=\"noopener\">http://localhost:8080/get_resource&quot;返回结果</a>  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//①</span></span><br><span class=\"line\">toufuStore | www.toufuStore.com | java</span><br></pre></td></tr></table></figure>\n\n</li>\n</ol>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//②</span></span><br><span class=\"line\"><span class=\"keyword\">null</span> | <span class=\"keyword\">null</span> | <span class=\"keyword\">null</span></span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//③</span></span><br><span class=\"line\">toufuStore | www.toufuStore.com | java</span><br></pre></td></tr></table></figure>\n\n","slug":"SpringBoot开发常用技术整合","updated":"2019-08-03T08:06:26.927Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/08/03/SpringBoot开发常用技术整合/","excerpt":"用.yml配置mysql连接删除resource下文件application.properties，创建文件application.yml 123456789server: port: 8080spring: datasource: name: toufu url: jdbc:mysql://39.108.73.179:3306/test1?useUnicode=true&amp;characterEncoding=UTF-8&amp;allowMultiQueries=true username: rootxxx password: rootpasswordxxx","categories":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://nojejesus.github.io/techTube/categories/Spring-Boot/"}],"tags":[]},{"title":"ThreadLocal深度理解","date":"2019-07-31T03:19:45.000Z","path":"2019/07/31/ThreadLocal深度理解/","text":"ThreadLocal是什么线程的本地副本，变量存储的工具类。将私有线程和该线程存放的对象副本做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 ThreadLocal的内部结构图 核心机制： 每个Thread线程内部有一个Map。 Map里面存储线程线程本地对象（key）和线程的变量副本（value）。 Map由ThreadLocal维护，由ThreadLocal负责向Map获取和设置线程的变量值。 所以，对于不同的线程，每次获取副本值时，其他线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。 Thread线程内部的Map在类中描述如下： 12345public class Thread implements Runnable &#123; /* ThreadLocal values pertaining to this thread. This map is maintained * by the ThreadLocal class. */ ThreadLocal.ThreadLocalMap threadLocals = null;&#125; ThreadLocal类提供如下几个核心方法： 123public T get()public void set(T value)public void remove() get() 获取当前线程的副本变量值 set() 保存当前线程的副本变量值 initialValue() 当前线程初始副本变量值 remove() 移除当前线程的副本变量值 get()方法12345678910111213141516171819202122232425262728293031323334353637/** * Returns the value in the current thread's copy of this * thread-local variable. If the variable has no value for the * current thread, it is first initialized to the value returned * by an invocation of the &#123;@link #initialValue&#125; method. * * @return the current thread's value of this thread-local */public T get() &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) &#123; ThreadLocalMap.Entry e = map.getEntry(this); if (e != null) return (T)e.value; &#125; return setInitialValue();&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;private T setInitialValue() &#123; T value = initialValue(); Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value); return value;&#125;protected T initialValue() &#123; return null;&#125; set()方法12345678910111213141516171819202122232425/** * Sets the current thread's copy of this thread-local variable * to the specified value. Most subclasses will have no need to * override this method, relying solely on the &#123;@link #initialValue&#125; * method to set the values of thread-locals. * * @param value the value to be stored in the current thread's copy of * this thread-local. */public void set(T value) &#123; Thread t = Thread.currentThread(); ThreadLocalMap map = getMap(t); if (map != null) map.set(this, value); else createMap(t, value);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125;void createMap(Thread t, T firstValue) &#123; t.threadLocals = new ThreadLocalMap(this, firstValue);&#125; remove()方法1234567891011121314151617181920/** * Removes the current thread's value for this thread-local * variable. If this thread-local variable is subsequently * &#123;@linkplain #get read&#125; by the current thread, its value will be * reinitialized by invoking its &#123;@link #initialValue&#125; method, * unless its value is &#123;@linkplain #set set&#125; by the current thread * in the interim. This may result in multiple invocations of the * &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread. * * @since 1.5 */public void remove() &#123; ThreadLocalMap m = getMap(Thread.currentThread()); if (m != null) m.remove(this);&#125;ThreadLocalMap getMap(Thread t) &#123; return t.threadLocals;&#125; ThreadLocalMapThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立方式实现了Map的功能，其内部的Entry也独立实现。 每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。 推荐阅读：ThreadLocal-面试必问深度解析一个故事讲明白线程的私家领地：ThreadLocalThreadLocal是否会引起内存溢出？","raw":"---\ntitle: ThreadLocal深度理解\ndate: 2019-07-31 11:19:45\ntags:\n- ThreadLocal\n- 线程安全\ncategories: \n- Java杂谈\n---\n## ThreadLocal是什么\n线程的本地副本，变量存储的工具类。  \n将私有线程和该线程存放的对象副本做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。\n## ThreadLocal的内部结构图\n<div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/ThreadLocal内部结构.jpg\" />\n</div>\n<!-- more -->\n核心机制：\n\n+ 每个Thread线程内部有一个Map。\n+ Map里面存储线程线程本地对象（key）和线程的变量副本（value）。\n+ Map由ThreadLocal维护，由ThreadLocal负责向Map获取和设置线程的变量值。\n\n所以，对于不同的线程，每次获取副本值时，其他线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。\n\nThread线程内部的Map在类中描述如下：\n```java\npublic class Thread implements Runnable {\n    /* ThreadLocal values pertaining to this thread. This map is maintained\n     * by the ThreadLocal class. */\n    ThreadLocal.ThreadLocalMap threadLocals = null;\n}\n```\n\nThreadLocal类提供如下几个核心方法：\n```java\npublic T get()\npublic void set(T value)\npublic void remove()\n```\n\n+ get() 获取当前线程的副本变量值\n+ set() 保存当前线程的副本变量值\n+ initialValue() 当前线程初始副本变量值\n+ remove() 移除当前线程的副本变量值\n\n### get()方法\n```java\n/**\n * Returns the value in the current thread's copy of this\n * thread-local variable.  If the variable has no value for the\n * current thread, it is first initialized to the value returned\n * by an invocation of the {@link #initialValue} method.\n *\n * @return the current thread's value of this thread-local\n */\npublic T get() {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null) {\n        ThreadLocalMap.Entry e = map.getEntry(this);\n        if (e != null)\n            return (T)e.value;\n    }\n    return setInitialValue();\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\nprivate T setInitialValue() {\n    T value = initialValue();\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n    return value;\n}\n\nprotected T initialValue() {\n    return null;\n}\n```\n\n### set()方法\n```java\n/**\n * Sets the current thread's copy of this thread-local variable\n * to the specified value.  Most subclasses will have no need to\n * override this method, relying solely on the {@link #initialValue}\n * method to set the values of thread-locals.\n *\n * @param value the value to be stored in the current thread's copy of\n *        this thread-local.\n */\npublic void set(T value) {\n    Thread t = Thread.currentThread();\n    ThreadLocalMap map = getMap(t);\n    if (map != null)\n        map.set(this, value);\n    else\n        createMap(t, value);\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n\nvoid createMap(Thread t, T firstValue) {\n    t.threadLocals = new ThreadLocalMap(this, firstValue);\n}\n```\n\n### remove()方法\n```java\n/**\n * Removes the current thread's value for this thread-local\n * variable.  If this thread-local variable is subsequently\n * {@linkplain #get read} by the current thread, its value will be\n * reinitialized by invoking its {@link #initialValue} method,\n * unless its value is {@linkplain #set set} by the current thread\n * in the interim.  This may result in multiple invocations of the\n * <tt>initialValue</tt> method in the current thread.\n *\n * @since 1.5\n */\npublic void remove() {\n ThreadLocalMap m = getMap(Thread.currentThread());\n if (m != null)\n     m.remove(this);\n}\n\nThreadLocalMap getMap(Thread t) {\n    return t.threadLocals;\n}\n```\n\n## ThreadLocalMap\nThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立方式实现了Map的功能，其内部的Entry也独立实现。\n<div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/ThreadLocalMap类图.png\" />\n</div>\n\n---\n\n每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。\n\n---\n\n推荐阅读：\n[ThreadLocal-面试必问深度解析](https://www.jianshu.com/p/98b68c97df9b)\n[一个故事讲明白线程的私家领地：ThreadLocal](https://mp.weixin.qq.com/s/k4cMqePHagb15-jlYh4PkA)\n[ThreadLocal是否会引起内存溢出？](https://blog.csdn.net/zhuyucheng123/article/details/30083337)","content":"<h2 id=\"ThreadLocal是什么\"><a href=\"#ThreadLocal是什么\" class=\"headerlink\" title=\"ThreadLocal是什么\"></a>ThreadLocal是什么</h2><p>线程的本地副本，变量存储的工具类。<br>将私有线程和该线程存放的对象副本做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。</p>\n<h2 id=\"ThreadLocal的内部结构图\"><a href=\"#ThreadLocal的内部结构图\" class=\"headerlink\" title=\"ThreadLocal的内部结构图\"></a>ThreadLocal的内部结构图</h2><div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/ThreadLocal内部结构.jpg\">\n</div>\n<a id=\"more\"></a>\n核心机制：\n\n<ul>\n<li>每个Thread线程内部有一个Map。</li>\n<li>Map里面存储线程线程本地对象（key）和线程的变量副本（value）。</li>\n<li>Map由ThreadLocal维护，由ThreadLocal负责向Map获取和设置线程的变量值。</li>\n</ul>\n<p>所以，对于不同的线程，每次获取副本值时，其他线程并不能获取到当前线程的副本值，形成了副本的隔离，互不干扰。</p>\n<p>Thread线程内部的Map在类中描述如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Thread</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/* ThreadLocal values pertaining to this thread. This map is maintained</span></span><br><span class=\"line\"><span class=\"comment\">     * by the ThreadLocal class. */</span></span><br><span class=\"line\">    ThreadLocal.ThreadLocalMap threadLocals = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>ThreadLocal类提供如下几个核心方法：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span></span><br></pre></td></tr></table></figure>\n\n<ul>\n<li>get() 获取当前线程的副本变量值</li>\n<li>set() 保存当前线程的副本变量值</li>\n<li>initialValue() 当前线程初始副本变量值</li>\n<li>remove() 移除当前线程的副本变量值</li>\n</ul>\n<h3 id=\"get-方法\"><a href=\"#get-方法\" class=\"headerlink\" title=\"get()方法\"></a>get()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Returns the value in the current thread's copy of this</span></span><br><span class=\"line\"><span class=\"comment\"> * thread-local variable.  If the variable has no value for the</span></span><br><span class=\"line\"><span class=\"comment\"> * current thread, it is first initialized to the value returned</span></span><br><span class=\"line\"><span class=\"comment\"> * by an invocation of the &#123;<span class=\"doctag\">@link</span> #initialValue&#125; method.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@return</span> the current thread's value of this thread-local</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> T <span class=\"title\">get</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ThreadLocalMap.Entry e = map.getEntry(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (e != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            <span class=\"keyword\">return</span> (T)e.value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> setInitialValue();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> T <span class=\"title\">setInitialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    T value = initialValue();</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> value;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> T <span class=\"title\">initialValue</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"set-方法\"><a href=\"#set-方法\" class=\"headerlink\" title=\"set()方法\"></a>set()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Sets the current thread's copy of this thread-local variable</span></span><br><span class=\"line\"><span class=\"comment\"> * to the specified value.  Most subclasses will have no need to</span></span><br><span class=\"line\"><span class=\"comment\"> * override this method, relying solely on the &#123;<span class=\"doctag\">@link</span> #initialValue&#125;</span></span><br><span class=\"line\"><span class=\"comment\"> * method to set the values of thread-locals.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@param</span> value the value to be stored in the current thread's copy of</span></span><br><span class=\"line\"><span class=\"comment\"> *        this thread-local.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(T value)</span> </span>&#123;</span><br><span class=\"line\">    Thread t = Thread.currentThread();</span><br><span class=\"line\">    ThreadLocalMap map = getMap(t);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (map != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        map.set(<span class=\"keyword\">this</span>, value);</span><br><span class=\"line\">    <span class=\"keyword\">else</span></span><br><span class=\"line\">        createMap(t, value);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">createMap</span><span class=\"params\">(Thread t, T firstValue)</span> </span>&#123;</span><br><span class=\"line\">    t.threadLocals = <span class=\"keyword\">new</span> ThreadLocalMap(<span class=\"keyword\">this</span>, firstValue);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"remove-方法\"><a href=\"#remove-方法\" class=\"headerlink\" title=\"remove()方法\"></a>remove()方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * Removes the current thread's value for this thread-local</span></span><br><span class=\"line\"><span class=\"comment\"> * variable.  If this thread-local variable is subsequently</span></span><br><span class=\"line\"><span class=\"comment\"> * &#123;<span class=\"doctag\">@linkplain</span> #get read&#125; by the current thread, its value will be</span></span><br><span class=\"line\"><span class=\"comment\"> * reinitialized by invoking its &#123;<span class=\"doctag\">@link</span> #initialValue&#125; method,</span></span><br><span class=\"line\"><span class=\"comment\"> * unless its value is &#123;<span class=\"doctag\">@linkplain</span> #set set&#125; by the current thread</span></span><br><span class=\"line\"><span class=\"comment\"> * in the interim.  This may result in multiple invocations of the</span></span><br><span class=\"line\"><span class=\"comment\"> * &lt;tt&gt;initialValue&lt;/tt&gt; method in the current thread.</span></span><br><span class=\"line\"><span class=\"comment\"> *</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@since</span> 1.5</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\"> ThreadLocalMap m = getMap(Thread.currentThread());</span><br><span class=\"line\"> <span class=\"keyword\">if</span> (m != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">     m.remove(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\">ThreadLocalMap <span class=\"title\">getMap</span><span class=\"params\">(Thread t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> t.threadLocals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"ThreadLocalMap\"><a href=\"#ThreadLocalMap\" class=\"headerlink\" title=\"ThreadLocalMap\"></a>ThreadLocalMap</h2><p>ThreadLocalMap是ThreadLocal的内部类，没有实现Map接口，用独立方式实现了Map的功能，其内部的Entry也独立实现。</p>\n<div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/ThreadLocalMap类图.png\">\n</div>\n\n<hr>\n<p>每个ThreadLocal只能保存一个变量副本，如果想要上线一个线程能够保存多个副本以上，就需要创建多个ThreadLocal。</p>\n<hr>\n<p>推荐阅读：<br><a href=\"https://www.jianshu.com/p/98b68c97df9b\" target=\"_blank\" rel=\"noopener\">ThreadLocal-面试必问深度解析</a><br><a href=\"https://mp.weixin.qq.com/s/k4cMqePHagb15-jlYh4PkA\" target=\"_blank\" rel=\"noopener\">一个故事讲明白线程的私家领地：ThreadLocal</a><br><a href=\"https://blog.csdn.net/zhuyucheng123/article/details/30083337\" target=\"_blank\" rel=\"noopener\">ThreadLocal是否会引起内存溢出？</a></p>\n","slug":"ThreadLocal深度理解","updated":"2019-07-31T04:13:54.756Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/31/ThreadLocal深度理解/","excerpt":"ThreadLocal是什么线程的本地副本，变量存储的工具类。将私有线程和该线程存放的对象副本做一个映射，各个线程之间的变量互不干扰，在高并发场景下，可以实现无状态的调用，特别适用于各个线程依赖不通的变量值完成操作的场景。 ThreadLocal的内部结构图","categories":[{"name":"Java杂谈","slug":"Java杂谈","permalink":"https://nojejesus.github.io/techTube/categories/Java杂谈/"}],"tags":[{"name":"ThreadLocal","slug":"ThreadLocal","permalink":"https://nojejesus.github.io/techTube/tags/ThreadLocal/"},{"name":"线程安全","slug":"线程安全","permalink":"https://nojejesus.github.io/techTube/tags/线程安全/"}]},{"title":"搞笑之为什么类中有get()和set()方法","date":"2019-07-31T02:57:54.000Z","path":"2019/07/31/搞笑之为什么类中有get-和set-方法/","text":"推荐阅读：关于面向对象编程中很多人用get()和set()方法，而不用public的一点总结 总结下我认为最重要是：通过get()和set()方法可以控制字段只能读不能写，或只能写不能读等。","raw":"---\ntitle: 搞笑之为什么类中有get()和set()方法\ndate: 2019-07-31 10:57:54\ntags:\ncategories: \n- Java杂谈\n---\n推荐阅读：  \n[关于面向对象编程中很多人用get()和set()方法，而不用public的一点总结](https://blog.csdn.net/llittlebird001/article/details/52725245)\n\n总结下我认为最重要是：通过get()和set()方法可以控制字段只能读不能写，或只能写不能读等。\n<!-- more -->","content":"<p>推荐阅读：<br><a href=\"https://blog.csdn.net/llittlebird001/article/details/52725245\" target=\"_blank\" rel=\"noopener\">关于面向对象编程中很多人用get()和set()方法，而不用public的一点总结</a></p>\n<p>总结下我认为最重要是：通过get()和set()方法可以控制字段只能读不能写，或只能写不能读等。</p>\n<a id=\"more\"></a>","slug":"搞笑之为什么类中有get-和set-方法","updated":"2019-07-31T03:01:29.116Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/31/搞笑之为什么类中有get-和set-方法/","excerpt":"推荐阅读：关于面向对象编程中很多人用get()和set()方法，而不用public的一点总结 总结下我认为最重要是：通过get()和set()方法可以控制字段只能读不能写，或只能写不能读等。","categories":[{"name":"Java杂谈","slug":"Java杂谈","permalink":"https://nojejesus.github.io/techTube/categories/Java杂谈/"}],"tags":[]},{"title":"Jenkins和Docker","date":"2019-07-31T00:49:25.000Z","path":"2019/07/31/Jenkins和Docker/","text":"推荐阅读：详解CI、CD相关概念Jenkins与Docker的自动化CI/CD实战Jenkins和Docker实现自动化构建部署","raw":"---\ntitle: Jenkins和Docker\ndate: 2019-07-31 08:49:25\ntags:\n- Jenkins\n- Docker\ncategories: \n---\n推荐阅读：  \n[详解CI、CD相关概念](https://blog.csdn.net/sinat_35930259/article/details/79429743)\n[Jenkins与Docker的自动化CI/CD实战](https://blog.51cto.com/qiuyt/2163950)\n[Jenkins和Docker实现自动化构建部署](https://blog.csdn.net/u010856384/article/details/79950980)\n\n<!-- more -->","content":"<p>推荐阅读：<br><a href=\"https://blog.csdn.net/sinat_35930259/article/details/79429743\" target=\"_blank\" rel=\"noopener\">详解CI、CD相关概念</a><br><a href=\"https://blog.51cto.com/qiuyt/2163950\" target=\"_blank\" rel=\"noopener\">Jenkins与Docker的自动化CI/CD实战</a><br><a href=\"https://blog.csdn.net/u010856384/article/details/79950980\" target=\"_blank\" rel=\"noopener\">Jenkins和Docker实现自动化构建部署</a></p>\n<a id=\"more\"></a>","slug":"Jenkins和Docker","updated":"2019-07-31T00:59:20.959Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/31/Jenkins和Docker/","excerpt":"推荐阅读：详解CI、CD相关概念Jenkins与Docker的自动化CI/CD实战Jenkins和Docker实现自动化构建部署","categories":[],"tags":[{"name":"Jenkins","slug":"Jenkins","permalink":"https://nojejesus.github.io/techTube/tags/Jenkins/"},{"name":"Docker","slug":"Docker","permalink":"https://nojejesus.github.io/techTube/tags/Docker/"}]},{"title":"深入理解Java虚拟机-自动内存管理机制","date":"2019-07-27T13:56:24.000Z","path":"2019/07/27/深入理解Java虚拟机-自动内存管理机制/","text":"自动内存管理机制Java虚拟机运行时数据区 由所有线程共享的数据区：方法区、堆 线程隔离的数据区：虚拟机栈、本地方法栈、程序计数器 程序计数器程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。 Java虚拟机栈与程序计数器一样，Java虚拟机栈也是线程私有的。生命周期与线程相同。虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（不等同对象本身，可能是个指向对象起始地址的引用指针）和returnAddress类型（指向一条字节码指令的地址）。 本地方法栈为虚拟机使用的Native方法服务。 Java堆对于大多数应用来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，是虚拟机启动时创建。 此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。 Java堆是垃圾收集器管理的主要区域，也被称为“GC堆”（Garbage Collected Heap）。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。 方法区和Java堆一样，是各个线程共享的内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。 运行时常量池是方法区的一部分。 对象的创建待续未完","raw":"---\ntitle: 深入理解Java虚拟机-自动内存管理机制\ndate: 2019-07-27 21:56:24\ntags:\n- Java虚拟机\ncategories: \n- 深入理解Java虚拟机\n---\n## 自动内存管理机制\n\n#### Java虚拟机运行时数据区\n+ 由所有线程共享的数据区：方法区、堆\n+ 线程隔离的数据区：虚拟机栈、本地方法栈、程序计数器\n\n---\n\n#### 程序计数器\n程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。\n<!-- more -->\n#### Java虚拟机栈\n与程序计数器一样，Java虚拟机栈也是线程私有的。生命周期与线程相同。\n虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。\n局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（不等同对象本身，可能是个指向对象起始地址的引用指针）和returnAddress类型（指向一条字节码指令的地址）。\n\n#### 本地方法栈\n为虚拟机使用的Native方法服务。\n\n---\n\n#### Java堆\n对于大多数应用来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，是虚拟机启动时创建。\n\n此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。\n\nJava堆是垃圾收集器管理的主要区域，也被称为“GC堆”（Garbage Collected Heap）。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。\n\n#### 方法区\n和Java堆一样，是各个线程共享的内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。\n\n运行时常量池是方法区的一部分。\n\n---\n\n---\n\n#### 对象的创建\n待续未完\n\n","content":"<h2 id=\"自动内存管理机制\"><a href=\"#自动内存管理机制\" class=\"headerlink\" title=\"自动内存管理机制\"></a>自动内存管理机制</h2><h4 id=\"Java虚拟机运行时数据区\"><a href=\"#Java虚拟机运行时数据区\" class=\"headerlink\" title=\"Java虚拟机运行时数据区\"></a>Java虚拟机运行时数据区</h4><ul>\n<li>由所有线程共享的数据区：方法区、堆</li>\n<li>线程隔离的数据区：虚拟机栈、本地方法栈、程序计数器</li>\n</ul>\n<hr>\n<h4 id=\"程序计数器\"><a href=\"#程序计数器\" class=\"headerlink\" title=\"程序计数器\"></a>程序计数器</h4><p>程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。</p>\n<a id=\"more\"></a>\n<h4 id=\"Java虚拟机栈\"><a href=\"#Java虚拟机栈\" class=\"headerlink\" title=\"Java虚拟机栈\"></a>Java虚拟机栈</h4><p>与程序计数器一样，Java虚拟机栈也是线程私有的。生命周期与线程相同。<br>虚拟机栈描述的是Java方法执行的内存模型：每个方法在执行时都会创建一个栈帧用于存储局部变量表、操作数栈、动态链接、方法出口等信息。<br>局部变量表存放了编译器可知的各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（不等同对象本身，可能是个指向对象起始地址的引用指针）和returnAddress类型（指向一条字节码指令的地址）。</p>\n<h4 id=\"本地方法栈\"><a href=\"#本地方法栈\" class=\"headerlink\" title=\"本地方法栈\"></a>本地方法栈</h4><p>为虚拟机使用的Native方法服务。</p>\n<hr>\n<h4 id=\"Java堆\"><a href=\"#Java堆\" class=\"headerlink\" title=\"Java堆\"></a>Java堆</h4><p>对于大多数应用来说，Java堆（Java Heap）是虚拟机所管理的内存中最大的一块。Java堆是被所有线程共享的一块内存区域，是虚拟机启动时创建。</p>\n<p>此内存区域的唯一目的就是存放对象实例，几乎所有的对象实例以及数组都在这里分配内存。</p>\n<p>Java堆是垃圾收集器管理的主要区域，也被称为“GC堆”（Garbage Collected Heap）。根据Java虚拟机规范的规定，Java堆可以处于物理上不连续的内存空间中，只要逻辑上是连续的即可，就像我们的磁盘空间一样。</p>\n<h4 id=\"方法区\"><a href=\"#方法区\" class=\"headerlink\" title=\"方法区\"></a>方法区</h4><p>和Java堆一样，是各个线程共享的内存区域，用于储存已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据。</p>\n<p>运行时常量池是方法区的一部分。</p>\n<hr>\n<hr>\n<h4 id=\"对象的创建\"><a href=\"#对象的创建\" class=\"headerlink\" title=\"对象的创建\"></a>对象的创建</h4><p>待续未完</p>\n","slug":"深入理解Java虚拟机-自动内存管理机制","updated":"2019-07-27T19:20:50.080Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/27/深入理解Java虚拟机-自动内存管理机制/","excerpt":"自动内存管理机制Java虚拟机运行时数据区 由所有线程共享的数据区：方法区、堆 线程隔离的数据区：虚拟机栈、本地方法栈、程序计数器 程序计数器程序计数器是一块较小的内存空间，它可以看作是当前线程所执行的字节码的行号指示器。","categories":[{"name":"深入理解Java虚拟机","slug":"深入理解Java虚拟机","permalink":"https://nojejesus.github.io/techTube/categories/深入理解Java虚拟机/"}],"tags":[{"name":"Java虚拟机","slug":"Java虚拟机","permalink":"https://nojejesus.github.io/techTube/tags/Java虚拟机/"}]},{"title":"来自Github的巨星","date":"2019-07-27T01:35:45.000Z","path":"2019/07/27/来自Github的巨星/","text":"Github项目","raw":"---\ntitle: 来自Github的巨星\ndate: 2019-07-27 09:35:45\ntags:\n- github\ncategories: \n- github\n---\n[Github项目](https://github.com/trending/java?since=monthly[1])\n<!-- more -->","content":"<p><a href=\"https://github.com/trending/java?since=monthly[1]\" target=\"_blank\" rel=\"noopener\">Github项目</a></p>\n<a id=\"more\"></a>","slug":"来自Github的巨星","updated":"2019-07-27T01:37:48.967Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/27/来自Github的巨星/","excerpt":"Github项目","categories":[{"name":"github","slug":"github","permalink":"https://nojejesus.github.io/techTube/categories/github/"}],"tags":[{"name":"github","slug":"github","permalink":"https://nojejesus.github.io/techTube/tags/github/"}]},{"title":"十大排序算法","date":"2019-07-27T00:56:19.000Z","path":"2019/07/27/十大排序算法/","text":"冒泡排序从序列的一端开始往另一端冒泡。 代码实现 展示代码 123456789101112131415//时间复杂度 o(n^2)public static void sort(int[] args) &#123; //冒泡轮数 for (int i = 0; i &lt; arr.length -1; i++) &#123; //依次两两比较 for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; int temp = 0; if (arr[j] &lt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j +1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125; 选择排序找到数组中最小（或最大）的元素，和数组中的第一个元素交换位置；在剩下的元素中找到最小（或最大）元素，和数组中的第二个元素交换位置，如此循环…直到整个数组排序完成。 代码实现 展示代码 123456789101112131415//时间复杂度 o(n^2)public static void sort(int arr[]) &#123; for (int i =0; i &lt; arr.length; i++) &#123; int min = i; //最小元素的下标 for (int j = i + 1; j &lt; arr.length; j++) &#123; if (arr[j] &lt; arr[min]) &#123; min = j; //找最小值 &#125; &#125; //交换位置 int temp = arr[i]; arr[i] = arr[min]; arr[min] = temp; &#125;&#125; 插入排序代码实现 展示代码 1234567891011121314151617//最好的时间复杂度是 o(n)，最坏的时间复杂度是 o(n^2)；//时间复杂度指标看的是最坏情况public static void sort(int[] arr) &#123; int n = arr.length; for (int i = 0; i &lt; n; i++) &#123; int value = arr[i]; int j = 0; //插入的位置 for (j = i - 1; j &gt;= 0; j--) &#123; if (arr[j] &gt; value) &#123; arr[j + 1] = arr[j]; //移动数据 &#125; else &#123; break; &#125; &#125; arr[j + 1] = value; //插入数据 &#125;&#125; 希尔排序待续未完 推荐阅读：这或许是东半球讲十大排序算法最好的一篇文章","raw":"---\ntitle: 十大排序算法\ndate: 2019-07-27 08:56:19\ntags:\n- 数据结构\n- 算法\ncategories:\n- 数据结构和算法\n---\n## 冒泡排序\n从序列的一端开始往另一端冒泡。\n### 代码实现\n<details>\n<summary><font color=darkred>展示代码</font></summary>\n\n```java\n//时间复杂度 o(n^2)\npublic static void sort(int[] args) {\n    //冒泡轮数\n    for (int i = 0; i < arr.length -1; i++) {\n        //依次两两比较\n        for (int j = 0; j <  arr.length - 1 - i; j++) {\n            int temp = 0;\n            if (arr[j] < arr[j + 1]) {\n                temp = arr[j];\n                arr[j] = arr[j +1];\n                arr[j + 1] = temp;\n            }\n        }\n    }\n}\n```\n\n</details>\n\n<!-- more -->\n## 选择排序\n找到数组中最小（或最大）的元素，和数组中的第一个元素交换位置；在剩下的元素中找到最小（或最大）元素，和数组中的第二个元素交换位置，如此循环...直到整个数组排序完成。\n### 代码实现\n<details>\n<summary><font color=darkred>展示代码</font></summary>\n\n```java\n//时间复杂度 o(n^2)\npublic static void sort(int arr[]) {\n    for (int i =0; i < arr.length; i++) {\n        int min = i; //最小元素的下标\n        for (int j = i + 1; j < arr.length; j++) {\n            if (arr[j] < arr[min]) {\n                min = j; //找最小值\n            }\n        }\n        //交换位置\n        int temp = arr[i];\n        arr[i] = arr[min];\n        arr[min] = temp;\n    }\n}\n```\n\n</details>\n\n## 插入排序\n### 代码实现\n<details>\n<summary><font color=darkred>展示代码</font></summary>\n\n```java\n//最好的时间复杂度是 o(n)，最坏的时间复杂度是 o(n^2)；\n//时间复杂度指标看的是最坏情况\npublic static void sort(int[] arr) {\n    int n = arr.length;\n    for (int i = 0; i < n; i++) {\n        int value = arr[i];\n        int j = 0; //插入的位置\n        for (j = i - 1; j >= 0; j--) {\n            if (arr[j] > value) {\n                arr[j + 1] = arr[j]; //移动数据\n            } else {\n                break;\n            }\n        }\n        arr[j + 1] = value; //插入数据\n    }\n}\n```\n</details>\n\n## 希尔排序\n### 待续未完\n\n---\n\n推荐阅读：\n[这或许是东半球讲十大排序算法最好的一篇文章](https://cxyxiaowu.com/articles/2019/06/11/1560233679033.html)","content":"<h2 id=\"冒泡排序\"><a href=\"#冒泡排序\" class=\"headerlink\" title=\"冒泡排序\"></a>冒泡排序</h2><p>从序列的一端开始往另一端冒泡。</p>\n<h3 id=\"代码实现\"><a href=\"#代码实现\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><details>\n<summary><font color=\"darkred\">展示代码</font></summary>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//时间复杂度 o(n^2)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] args)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//冒泡轮数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; arr.length -<span class=\"number\">1</span>; i++) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//依次两两比较</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; j &lt;  arr.length - <span class=\"number\">1</span> - i; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> temp = <span class=\"number\">0</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[j + <span class=\"number\">1</span>]) &#123;</span><br><span class=\"line\">                temp = arr[j];</span><br><span class=\"line\">                arr[j] = arr[j +<span class=\"number\">1</span>];</span><br><span class=\"line\">                arr[j + <span class=\"number\">1</span>] = temp;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<a id=\"more\"></a>\n<h2 id=\"选择排序\"><a href=\"#选择排序\" class=\"headerlink\" title=\"选择排序\"></a>选择排序</h2><p>找到数组中最小（或最大）的元素，和数组中的第一个元素交换位置；在剩下的元素中找到最小（或最大）元素，和数组中的第二个元素交换位置，如此循环…直到整个数组排序完成。</p>\n<h3 id=\"代码实现-1\"><a href=\"#代码实现-1\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><details>\n<summary><font color=\"darkred\">展示代码</font></summary>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//时间复杂度 o(n^2)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span> arr[])</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i =<span class=\"number\">0</span>; i &lt; arr.length; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> min = i; <span class=\"comment\">//最小元素的下标</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> j = i + <span class=\"number\">1</span>; j &lt; arr.length; j++) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &lt; arr[min]) &#123;</span><br><span class=\"line\">                min = j; <span class=\"comment\">//找最小值</span></span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//交换位置</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> temp = arr[i];</span><br><span class=\"line\">        arr[i] = arr[min];</span><br><span class=\"line\">        arr[min] = temp;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<h2 id=\"插入排序\"><a href=\"#插入排序\" class=\"headerlink\" title=\"插入排序\"></a>插入排序</h2><h3 id=\"代码实现-2\"><a href=\"#代码实现-2\" class=\"headerlink\" title=\"代码实现\"></a>代码实现</h3><details>\n<summary><font color=\"darkred\">展示代码</font></summary>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//最好的时间复杂度是 o(n)，最坏的时间复杂度是 o(n^2)；</span></span><br><span class=\"line\"><span class=\"comment\">//时间复杂度指标看的是最坏情况</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(<span class=\"keyword\">int</span>[] arr)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = arr.length;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; n; i++) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> value = arr[i];</span><br><span class=\"line\">        <span class=\"keyword\">int</span> j = <span class=\"number\">0</span>; <span class=\"comment\">//插入的位置</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (j = i - <span class=\"number\">1</span>; j &gt;= <span class=\"number\">0</span>; j--) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (arr[j] &gt; value) &#123;</span><br><span class=\"line\">                arr[j + <span class=\"number\">1</span>] = arr[j]; <span class=\"comment\">//移动数据</span></span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        arr[j + <span class=\"number\">1</span>] = value; <span class=\"comment\">//插入数据</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<h2 id=\"希尔排序\"><a href=\"#希尔排序\" class=\"headerlink\" title=\"希尔排序\"></a>希尔排序</h2><h3 id=\"待续未完\"><a href=\"#待续未完\" class=\"headerlink\" title=\"待续未完\"></a>待续未完</h3><hr>\n<p>推荐阅读：<br><a href=\"https://cxyxiaowu.com/articles/2019/06/11/1560233679033.html\" target=\"_blank\" rel=\"noopener\">这或许是东半球讲十大排序算法最好的一篇文章</a></p>\n","slug":"十大排序算法","updated":"2019-07-27T01:32:39.838Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/27/十大排序算法/","excerpt":"冒泡排序从序列的一端开始往另一端冒泡。 代码实现 展示代码 123456789101112131415//时间复杂度 o(n^2)public static void sort(int[] args) &#123; //冒泡轮数 for (int i = 0; i &lt; arr.length -1; i++) &#123; //依次两两比较 for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; int temp = 0; if (arr[j] &lt; arr[j + 1]) &#123; temp = arr[j]; arr[j] = arr[j +1]; arr[j + 1] = temp; &#125; &#125; &#125;&#125;","categories":[{"name":"数据结构和算法","slug":"数据结构和算法","permalink":"https://nojejesus.github.io/techTube/categories/数据结构和算法/"}],"tags":[{"name":"数据结构","slug":"数据结构","permalink":"https://nojejesus.github.io/techTube/tags/数据结构/"},{"name":"算法","slug":"算法","permalink":"https://nojejesus.github.io/techTube/tags/算法/"}]},{"title":"Java动态代理","date":"2019-07-25T11:25:02.000Z","path":"2019/07/25/Java动态代理/","text":"推荐阅读：你真的完全了解Java动态代理吗？看这篇就够了Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）Java两种动态代理JDK动态代理和CGLIB动态代理Java动态代理 深度详解","raw":"---\ntitle: Java动态代理\ndate: 2019-07-25 19:25:02\ntags:\n- 动态代理\ncategories: \n- Java杂谈\n---\n推荐阅读：\n[你真的完全了解Java动态代理吗？看这篇就够了](https://www.jianshu.com/p/95970b089360)\n[Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）](https://www.cnblogs.com/rinack/p/7742682.html)\n[Java两种动态代理JDK动态代理和CGLIB动态代理](https://blog.csdn.net/flyfeifei66/article/details/81481222)\n[Java动态代理 深度详解](https://www.cnblogs.com/midiyu/p/7878609.html)\n<!-- more -->","content":"<p>推荐阅读：<br><a href=\"https://www.jianshu.com/p/95970b089360\" target=\"_blank\" rel=\"noopener\">你真的完全了解Java动态代理吗？看这篇就够了</a><br><a href=\"https://www.cnblogs.com/rinack/p/7742682.html\" target=\"_blank\" rel=\"noopener\">Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）</a><br><a href=\"https://blog.csdn.net/flyfeifei66/article/details/81481222\" target=\"_blank\" rel=\"noopener\">Java两种动态代理JDK动态代理和CGLIB动态代理</a><br><a href=\"https://www.cnblogs.com/midiyu/p/7878609.html\" target=\"_blank\" rel=\"noopener\">Java动态代理 深度详解</a></p>\n<a id=\"more\"></a>","slug":"Java动态代理","updated":"2019-07-25T11:45:33.592Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/25/Java动态代理/","excerpt":"推荐阅读：你真的完全了解Java动态代理吗？看这篇就够了Java动态代理机制详解（JDK 和CGLIB，Javassist，ASM）Java两种动态代理JDK动态代理和CGLIB动态代理Java动态代理 深度详解","categories":[{"name":"Java杂谈","slug":"Java杂谈","permalink":"https://nojejesus.github.io/techTube/categories/Java杂谈/"}],"tags":[{"name":"动态代理","slug":"动态代理","permalink":"https://nojejesus.github.io/techTube/tags/动态代理/"}]},{"title":"Spring之事务","date":"2019-07-24T13:08:43.000Z","path":"2019/07/24/Spring之事务/","text":"推荐阅读：Spring事务管理（详解+实例）Spring配置事务五种方式Spring事务管理的四种方式（以银行转账为例）Spring事务传播行为详解spring事务管理","raw":"---\ntitle: Spring之事务\ndate: 2019-07-24 21:08:43\ntags:\n- 事务\ncategories:\n- Spring框架\n- Spring\n---\n推荐阅读：\n======\n[Spring事务管理（详解+实例）](https://blog.csdn.net/trigl/article/details/50968079)\n[Spring配置事务五种方式](https://www.jianshu.com/p/93bc4a8ebd0d)\n[Spring事务管理的四种方式（以银行转账为例）](https://blog.csdn.net/daijin888888/article/details/51822257)\n[Spring事务传播行为详解](https://segmentfault.com/a/1190000013341344#articleHeader17)\n[spring事务管理](https://yq.aliyun.com/articles/630179)\n<!-- more -->\n","content":"<h1 id=\"推荐阅读：\"><a href=\"#推荐阅读：\" class=\"headerlink\" title=\"推荐阅读：\"></a>推荐阅读：</h1><p><a href=\"https://blog.csdn.net/trigl/article/details/50968079\" target=\"_blank\" rel=\"noopener\">Spring事务管理（详解+实例）</a><br><a href=\"https://www.jianshu.com/p/93bc4a8ebd0d\" target=\"_blank\" rel=\"noopener\">Spring配置事务五种方式</a><br><a href=\"https://blog.csdn.net/daijin888888/article/details/51822257\" target=\"_blank\" rel=\"noopener\">Spring事务管理的四种方式（以银行转账为例）</a><br><a href=\"https://segmentfault.com/a/1190000013341344#articleHeader17\" target=\"_blank\" rel=\"noopener\">Spring事务传播行为详解</a><br><a href=\"https://yq.aliyun.com/articles/630179\" target=\"_blank\" rel=\"noopener\">spring事务管理</a></p>\n<a id=\"more\"></a>\n","slug":"Spring之事务","updated":"2019-07-24T13:52:09.822Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/24/Spring之事务/","excerpt":"推荐阅读：Spring事务管理（详解+实例）Spring配置事务五种方式Spring事务管理的四种方式（以银行转账为例）Spring事务传播行为详解spring事务管理","categories":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/"},{"name":"Spring","slug":"Spring框架/Spring","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/Spring/"}],"tags":[{"name":"事务","slug":"事务","permalink":"https://nojejesus.github.io/techTube/tags/事务/"}]},{"title":"注解@Autowired和@Resource","date":"2019-07-24T04:13:21.000Z","path":"2019/07/24/注解-Autowire和-Resource/","text":"场景当一个接口有多个实现类时，Spring的Bean注入要指定继承类，主要有以下两种方式： @Resource是JDK提供的注解，默认按照by-name方式寻找bean，一般一个name对应一个bean，当找不到与名称匹配的bean才会按照类型装配（by-type）。当注解写在字段上，默认取字段名进行查找，如果name属性一旦指定，就只会按照名称来装配。@Autowired是Spring提供的注解，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置他的required属性为false。如果我们想使用名称装配可以结合@Quality注解指定Bean的名称使用。 接口123public interface UserService &#123; User findById(int id);&#125; 实现类123456789101112131415161718192021@Service(\"userService1\")@transactional(\"firstTransactionManager\")public class UserServiceImpl implements UserService &#123; @Autowired private UserRepository userRepository; @Override public User findById(int id) &#123; return this.userRepository.findOne(id); &#125; &#125;@Service(\"userService2\")@Transactional(\"secondTransactionManager\")public class UserSecondServiceImpl implements UserService &#123; @Autowired private UserSecondRepository userRepository; @Override public User findById(int id) &#123; return this.userRepository.findOne(id); &#125;&#125; 注入方式123456@Autowired@Qualifier(\"userService3\")private UserService userService;---or@Resource(name = \"userService3\")private UserService userService; 另外，@Autowired属于Spring，@Resource属于J2EE，@Resource可以减少与Spring的耦合，代码更优雅。 推荐阅读:Spring中注解@Autowired与@Resource的依赖注入源码分析https://blog.csdn.net/bawcwchen/article/details/79793288 Spring annotation中,@resource如何找到实现类的https://blog.csdn.net/zc_ad/article/details/78124269 在普通Java类里使用spring里注入的service、dao等https://blog.csdn.net/tianyaleixiaowu/article/details/54630383 Spring IOC容器的自动装配源码级解析","raw":"---\ntitle: 注解@Autowired和@Resource\ndate: 2019-07-24 12:13:21\ntags:\ncategories: \n- Spring框架\n- Spring\n---\n## 场景\n当一个接口有多个实现类时，Spring的Bean注入要指定继承类，主要有以下两种方式：\n> @Resource是JDK提供的注解，默认按照by-name方式寻找bean，一般一个name对应一个bean，当找不到与名称匹配的bean才会按照类型装配（by-type）。当注解写在字段上，默认取字段名进行查找，如果name属性一旦指定，就只会按照名称来装配。 \n> @Autowired是Spring提供的注解，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置他的required属性为false。如果我们想使用名称装配可以结合@Quality注解指定Bean的名称使用。\n\n### 接口\n```java\npublic interface UserService {\n    User findById(int id);\n}\n```\n<!-- more -->\n### 实现类\n```java\n@Service(\"userService1\")\n@transactional(\"firstTransactionManager\")\npublic class UserServiceImpl implements UserService {\n    @Autowired\n    private UserRepository userRepository;\n    @Override\n    public User findById(int id) {\n        return this.userRepository.findOne(id);\n    } \n}\n\n@Service(\"userService2\")\n@Transactional(\"secondTransactionManager\")\npublic class UserSecondServiceImpl implements UserService {\n    @Autowired\n    private UserSecondRepository userRepository;\n    @Override\n    public User findById(int id) {\n        return this.userRepository.findOne(id);\n    }\n}\n```\n\n### 注入方式\n```java\n@Autowired\n@Qualifier(\"userService3\")\nprivate UserService userService;\n---or\n@Resource(name = \"userService3\")\nprivate UserService userService;\n```\n\n另外，@Autowired属于Spring，@Resource属于J2EE，@Resource可以减少与Spring的耦合，代码更优雅。\n\n推荐阅读:  \nSpring中注解@Autowired与@Resource的依赖注入源码分析\nhttps://blog.csdn.net/bawcwchen/article/details/79793288\n\nSpring annotation中,@resource如何找到实现类的\nhttps://blog.csdn.net/zc_ad/article/details/78124269\n\n在普通Java类里使用spring里注入的service、dao等\nhttps://blog.csdn.net/tianyaleixiaowu/article/details/54630383\n\n[Spring IOC容器的自动装配源码级解析](https://blog.csdn.net/f641385712/article/details/88410362)","content":"<h2 id=\"场景\"><a href=\"#场景\" class=\"headerlink\" title=\"场景\"></a>场景</h2><p>当一个接口有多个实现类时，Spring的Bean注入要指定继承类，主要有以下两种方式：</p>\n<blockquote>\n<p>@Resource是JDK提供的注解，默认按照by-name方式寻找bean，一般一个name对应一个bean，当找不到与名称匹配的bean才会按照类型装配（by-type）。当注解写在字段上，默认取字段名进行查找，如果name属性一旦指定，就只会按照名称来装配。<br>@Autowired是Spring提供的注解，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置他的required属性为false。如果我们想使用名称装配可以结合@Quality注解指定Bean的名称使用。</p>\n</blockquote>\n<h3 id=\"接口\"><a href=\"#接口\" class=\"headerlink\" title=\"接口\"></a>接口</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">User <span class=\"title\">findById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<a id=\"more\"></a>\n<h3 id=\"实现类\"><a href=\"#实现类\" class=\"headerlink\" title=\"实现类\"></a>实现类</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Service</span>(<span class=\"string\">\"userService1\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@transactional</span>(<span class=\"string\">\"firstTransactionManager\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserRepository userRepository;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">findById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.userRepository.findOne(id);</span><br><span class=\"line\">    &#125; </span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Service</span>(<span class=\"string\">\"userService2\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@Transactional</span>(<span class=\"string\">\"secondTransactionManager\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">UserSecondServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">UserService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> UserSecondRepository userRepository;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> User <span class=\"title\">findById</span><span class=\"params\">(<span class=\"keyword\">int</span> id)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">this</span>.userRepository.findOne(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"注入方式\"><a href=\"#注入方式\" class=\"headerlink\" title=\"注入方式\"></a>注入方式</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Autowired</span></span><br><span class=\"line\"><span class=\"meta\">@Qualifier</span>(<span class=\"string\">\"userService3\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> UserService userService;</span><br><span class=\"line\">---or</span><br><span class=\"line\"><span class=\"meta\">@Resource</span>(name = <span class=\"string\">\"userService3\"</span>)</span><br><span class=\"line\"><span class=\"keyword\">private</span> UserService userService;</span><br></pre></td></tr></table></figure>\n\n<p>另外，@Autowired属于Spring，@Resource属于J2EE，@Resource可以减少与Spring的耦合，代码更优雅。</p>\n<p>推荐阅读:<br>Spring中注解@Autowired与@Resource的依赖注入源码分析<br><a href=\"https://blog.csdn.net/bawcwchen/article/details/79793288\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/bawcwchen/article/details/79793288</a></p>\n<p>Spring annotation中,@resource如何找到实现类的<br><a href=\"https://blog.csdn.net/zc_ad/article/details/78124269\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/zc_ad/article/details/78124269</a></p>\n<p>在普通Java类里使用spring里注入的service、dao等<br><a href=\"https://blog.csdn.net/tianyaleixiaowu/article/details/54630383\" target=\"_blank\" rel=\"noopener\">https://blog.csdn.net/tianyaleixiaowu/article/details/54630383</a></p>\n<p><a href=\"https://blog.csdn.net/f641385712/article/details/88410362\" target=\"_blank\" rel=\"noopener\">Spring IOC容器的自动装配源码级解析</a></p>\n","slug":"注解-Autowire和-Resource","updated":"2019-07-29T05:10:53.202Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/24/注解-Autowire和-Resource/","excerpt":"场景当一个接口有多个实现类时，Spring的Bean注入要指定继承类，主要有以下两种方式： @Resource是JDK提供的注解，默认按照by-name方式寻找bean，一般一个name对应一个bean，当找不到与名称匹配的bean才会按照类型装配（by-type）。当注解写在字段上，默认取字段名进行查找，如果name属性一旦指定，就只会按照名称来装配。@Autowired是Spring提供的注解，默认情况下必须要求依赖对象必须存在，如果要允许null值，可以设置他的required属性为false。如果我们想使用名称装配可以结合@Quality注解指定Bean的名称使用。 接口123public interface UserService &#123; User findById(int id);&#125;","categories":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/"},{"name":"Spring","slug":"Spring框架/Spring","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/Spring/"}],"tags":[]},{"title":"Spring全局异常拦截及公共响应对象的实现","date":"2019-07-21T18:09:17.000Z","path":"2019/07/22/Spring全局异常拦截及公共响应对象的实现/","text":"SpringMVC的三种全局异常拦截处理方式 使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver 实现Spring的异常处理接口HandleExceptionResolver 使用@ExceptionHandler注解 公共响应对象的封装 JsonData类封装了一个通用的返回结构，并不具备拦截器功能。 [展示代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.jjstore.common;import lombok.Getter;import lombok.Setter;import java.util.HashMap;import java.util.Map;/** * 定义接口json数据返回的结构 */@Getter@Setterpublic class JsonData &#123; private boolean ret; //返回结果 private String msg; //提示信息 private Object data; //返回的数据 public JsonData(boolean ret) &#123; this.ret = ret; &#125; public static JsonData success(Object object, String msg) &#123; JsonData jsonData = new JsonData(true); jsonData.msg = msg; jsonData.data = object; return jsonData; &#125; public static JsonData success(Object object) &#123; JsonData jsonData = new JsonData(true); jsonData.data = object; return jsonData; &#125; public static JsonData success() &#123; return new JsonData(true); &#125; public static JsonData fail(String msg) &#123; JsonData jsonData = new JsonData(false); jsonData.msg = msg; return jsonData; &#125; public Map&lt;String, Object&gt; toMap() &#123; HashMap&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put(\"ret\", ret); result.put(\"msg\", msg); result.put(\"data\", data); return result; &#125;&#125; 全局异常拦截器的实现 为什么要做全局异常拦截？如果我们不拦截，后端的异常直接抛到前端，例如像tomcat那个看起来特别丑的界面或者显示异常对象的样板代码，体验是很不友好的。实际开发中是不允许的出现这种情况的。全局异常拦截器的实现是我们期望在任何情况下都能按照一个统一结构返回给前端控制器，这是一种优雅的设计方式。拦截器实现代码（其中PermissionException和ParamException是自定义的异常类）： [展示代码] 123456789101112131415161718192021222324252627282930313233343536373839404142package com.jjstore.common;import com.jjstore.exception.ParamException;import com.jjstore.exception.PermissionException;import lombok.extern.slf4j.Slf4j;import org.springframework.web.servlet.HandlerExceptionResolver;import org.springframework.web.servlet.ModelAndView;@Slf4jpublic class SpringExceptionResolver implements HandlerExceptionResolver &#123; @Override public ModelAndView resolveException(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex) &#123; //获取当前访问的url String url = request.getRequestURL().toString(); ModelAndView mv; String defaultMsg = \"System error\"; //对数据请求和页面请求分别做异常处理 //那么我们如何判断当前的请求是数据请求还是页面请求呢？--方案一：从request里取得header，来判断请求类型，实现较复杂； //方案二：通过自定义接口规范，如所有接口json数据请求使用.json结尾，所有页面请求使用.page结尾。则通过此后缀来判断。 //所以本项目要求所有请求json数据，都使用.json结尾；请求page页面，都是用.page结尾。 if (url.endsWith(\".json\")) &#123; if (ex instanceof PermissionException || ex instanceof ParamException) &#123; JsonData result = JsonData.fail(ex.getMessage()); mv = new ModelAndView(\"jsonView\", result.toMap()); &#125; else &#123; //log日志记录请求的url，打印ex堆栈 log.error(\"unknow json exception, url:\" + url, ex); JsonData result = JsonData.fail(defaultMsg); mv = new ModelAndView(\"jsonView\", result.toMap()); &#125; &#125; else if (url.endsWith(\".page\")) &#123; log.error(\"unknow page exception, url:\" + url, ex); JsonData result = JsonData.fail(defaultMsg); mv = new ModelAndView(\"exception\", result.toMap()); &#125; else &#123; log.error(\"unknow exception, url:\" + url, ex); JsonData result = JsonData.fail(defaultMsg); mv = new ModelAndView(\"jsonView\", result.toMap()); &#125; return mv; &#125;&#125; 在spring-servlet.xml中添加这个bean [展示代码] 12&lt;!-- 全局异常处理类 --&gt;&lt;bean class=\"com.jjstore.common.SpringExceptionResolver\" /&gt;","raw":"---\ntitle: Spring全局异常拦截及公共响应对象的实现\ndate: 2019-07-22 02:09:17\ntags:\ncategories: \n- projects #一级分类\n- permission #二级分类\n---\n### SpringMVC的三种全局异常拦截处理方式\n+ 使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver\n+ 实现Spring的异常处理接口HandleExceptionResolver\n+ 使用@ExceptionHandler注解\n\n### 公共响应对象的封装\n+ JsonData类封装了一个通用的返回结构，并不具备拦截器功能。\n    <details>\n    <summary><font color=darkred>[展示代码]</font></summary>\n\n    ```java\n    package com.jjstore.common;\n\n    import lombok.Getter;\n    import lombok.Setter;\n\n    import java.util.HashMap;\n    import java.util.Map;\n\n    /**\n     * 定义接口json数据返回的结构\n     */\n    @Getter\n    @Setter\n    public class JsonData {\n\n        private boolean ret;  //返回结果\n        private String msg;  //提示信息\n        private Object data;  //返回的数据\n\n        public JsonData(boolean ret) {\n            this.ret = ret;\n        }\n\n        public static JsonData success(Object object, String msg) {\n            JsonData jsonData = new JsonData(true);\n            jsonData.msg = msg;\n            jsonData.data = object;\n            return jsonData;\n        }\n\n        public static JsonData success(Object object) {\n            JsonData jsonData = new JsonData(true);\n            jsonData.data = object;\n            return jsonData;\n        }\n\n        public static JsonData success() {\n            return new JsonData(true);\n        }\n\n        public static JsonData fail(String msg) {\n            JsonData jsonData = new JsonData(false);\n            jsonData.msg = msg;\n            return jsonData;\n        }\n\n        public Map<String, Object> toMap() {\n            HashMap<String, Object> result = new HashMap<>();\n            result.put(\"ret\", ret);\n            result.put(\"msg\", msg);\n            result.put(\"data\", data);\n            return result;\n        }\n\n    }\n    ```\n    </details><br>\n<!-- more -->\n\n### 全局异常拦截器的实现\n+ 为什么要做全局异常拦截？\n如果我们不拦截，后端的异常直接抛到前端，例如像tomcat那个看起来特别丑的界面或者显示异常对象的样板代码，体验是很不友好的。实际开发中是不允许的出现这种情况的。全局异常拦截器的实现是我们期望在任何情况下都能按照一个统一结构返回给前端控制器，这是一种优雅的设计方式。\n拦截器实现代码（其中PermissionException和ParamException是自定义的异常类）：\n<details>\n    <summary><font color=darkred>[展示代码]</font></summary>\n\n    ```java\n    package com.jjstore.common;\n\n    import com.jjstore.exception.ParamException;\n    import com.jjstore.exception.PermissionException;\n    import lombok.extern.slf4j.Slf4j;\n    import org.springframework.web.servlet.HandlerExceptionResolver;\n    import org.springframework.web.servlet.ModelAndView;\n\n    @Slf4j\n    public class SpringExceptionResolver implements HandlerExceptionResolver {\n        @Override\n        public ModelAndView resolveException(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex) {\n            //获取当前访问的url\n            String url = request.getRequestURL().toString();\n            ModelAndView mv;\n            String defaultMsg = \"System error\";\n            //对数据请求和页面请求分别做异常处理\n            //那么我们如何判断当前的请求是数据请求还是页面请求呢？--方案一：从request里取得header，来判断请求类型，实现较复杂；\n            //方案二：通过自定义接口规范，如所有接口json数据请求使用.json结尾，所有页面请求使用.page结尾。则通过此后缀来判断。\n            //所以本项目要求所有请求json数据，都使用.json结尾；请求page页面，都是用.page结尾。\n            if (url.endsWith(\".json\")) {\n                if (ex instanceof PermissionException || ex instanceof ParamException) {\n                    JsonData result = JsonData.fail(ex.getMessage());\n                    mv = new ModelAndView(\"jsonView\", result.toMap());\n                } else {\n                    //log日志记录请求的url，打印ex堆栈\n                    log.error(\"unknow json exception, url:\" + url, ex);\n                    JsonData result = JsonData.fail(defaultMsg);\n                    mv = new ModelAndView(\"jsonView\", result.toMap());\n                }\n            } else if (url.endsWith(\".page\")) {\n                log.error(\"unknow page exception, url:\" + url, ex);\n                JsonData result = JsonData.fail(defaultMsg);\n                mv = new ModelAndView(\"exception\", result.toMap());\n            } else {\n                log.error(\"unknow exception, url:\" + url, ex);\n                JsonData result = JsonData.fail(defaultMsg);\n                mv = new ModelAndView(\"jsonView\", result.toMap());\n            }\n            return mv;\n        }\n    }\n    ```\n</details><br>\n\n+ 在spring-servlet.xml中添加这个bean\n<details>\n<summary><font color=darkred>[展示代码]</font></summary>\n```java\n<!-- 全局异常处理类 -->\n<bean class=\"com.jjstore.common.SpringExceptionResolver\" />\n```\n</details><br>","content":"<h3 id=\"SpringMVC的三种全局异常拦截处理方式\"><a href=\"#SpringMVC的三种全局异常拦截处理方式\" class=\"headerlink\" title=\"SpringMVC的三种全局异常拦截处理方式\"></a>SpringMVC的三种全局异常拦截处理方式</h3><ul>\n<li>使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver</li>\n<li>实现Spring的异常处理接口HandleExceptionResolver</li>\n<li>使用@ExceptionHandler注解</li>\n</ul>\n<h3 id=\"公共响应对象的封装\"><a href=\"#公共响应对象的封装\" class=\"headerlink\" title=\"公共响应对象的封装\"></a>公共响应对象的封装</h3><ul>\n<li><p>JsonData类封装了一个通用的返回结构，并不具备拦截器功能。</p>\n  <details>\n  <summary><font color=\"darkred\">[展示代码]</font></summary>\n\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jjstore.common;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.Getter;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.Setter;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.HashMap;</span><br><span class=\"line\"><span class=\"keyword\">import</span> java.util.Map;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 定义接口json数据返回的结构</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"meta\">@Getter</span></span><br><span class=\"line\"><span class=\"meta\">@Setter</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">JsonData</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> ret;  <span class=\"comment\">//返回结果</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> String msg;  <span class=\"comment\">//提示信息</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> Object data;  <span class=\"comment\">//返回的数据</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">JsonData</span><span class=\"params\">(<span class=\"keyword\">boolean</span> ret)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.ret = ret;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JsonData <span class=\"title\">success</span><span class=\"params\">(Object object, String msg)</span> </span>&#123;</span><br><span class=\"line\">        JsonData jsonData = <span class=\"keyword\">new</span> JsonData(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        jsonData.msg = msg;</span><br><span class=\"line\">        jsonData.data = object;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JsonData <span class=\"title\">success</span><span class=\"params\">(Object object)</span> </span>&#123;</span><br><span class=\"line\">        JsonData jsonData = <span class=\"keyword\">new</span> JsonData(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        jsonData.data = object;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JsonData <span class=\"title\">success</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> JsonData(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> JsonData <span class=\"title\">fail</span><span class=\"params\">(String msg)</span> </span>&#123;</span><br><span class=\"line\">        JsonData jsonData = <span class=\"keyword\">new</span> JsonData(<span class=\"keyword\">false</span>);</span><br><span class=\"line\">        jsonData.msg = msg;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> jsonData;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Map&lt;String, Object&gt; <span class=\"title\">toMap</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        HashMap&lt;String, Object&gt; result = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">        result.put(<span class=\"string\">\"ret\"</span>, ret);</span><br><span class=\"line\">        result.put(<span class=\"string\">\"msg\"</span>, msg);</span><br><span class=\"line\">        result.put(<span class=\"string\">\"data\"</span>, data);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> result;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n  </details><br>\n<a id=\"more\"></a>\n\n</li>\n</ul>\n<h3 id=\"全局异常拦截器的实现\"><a href=\"#全局异常拦截器的实现\" class=\"headerlink\" title=\"全局异常拦截器的实现\"></a>全局异常拦截器的实现</h3><ul>\n<li><p>为什么要做全局异常拦截？<br>如果我们不拦截，后端的异常直接抛到前端，例如像tomcat那个看起来特别丑的界面或者显示异常对象的样板代码，体验是很不友好的。实际开发中是不允许的出现这种情况的。全局异常拦截器的实现是我们期望在任何情况下都能按照一个统一结构返回给前端控制器，这是一种优雅的设计方式。<br>拦截器实现代码（其中PermissionException和ParamException是自定义的异常类）：</p>\n<details>\n  <summary><font color=\"darkred\">[展示代码]</font></summary>\n\n  <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">package</span> com.jjstore.common;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jjstore.exception.ParamException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> com.jjstore.exception.PermissionException;</span><br><span class=\"line\"><span class=\"keyword\">import</span> lombok.extern.slf4j.Slf4j;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.HandlerExceptionResolver;</span><br><span class=\"line\"><span class=\"keyword\">import</span> org.springframework.web.servlet.ModelAndView;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SpringExceptionResolver</span> <span class=\"keyword\">implements</span> <span class=\"title\">HandlerExceptionResolver</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> ModelAndView <span class=\"title\">resolveException</span><span class=\"params\">(javax.servlet.http.HttpServletRequest request, javax.servlet.http.HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取当前访问的url</span></span><br><span class=\"line\">        String url = request.getRequestURL().toString();</span><br><span class=\"line\">        ModelAndView mv;</span><br><span class=\"line\">        String defaultMsg = <span class=\"string\">\"System error\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">//对数据请求和页面请求分别做异常处理</span></span><br><span class=\"line\">        <span class=\"comment\">//那么我们如何判断当前的请求是数据请求还是页面请求呢？--方案一：从request里取得header，来判断请求类型，实现较复杂；</span></span><br><span class=\"line\">        <span class=\"comment\">//方案二：通过自定义接口规范，如所有接口json数据请求使用.json结尾，所有页面请求使用.page结尾。则通过此后缀来判断。</span></span><br><span class=\"line\">        <span class=\"comment\">//所以本项目要求所有请求json数据，都使用.json结尾；请求page页面，都是用.page结尾。</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (url.endsWith(<span class=\"string\">\".json\"</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ex <span class=\"keyword\">instanceof</span> PermissionException || ex <span class=\"keyword\">instanceof</span> ParamException) &#123;</span><br><span class=\"line\">                JsonData result = JsonData.fail(ex.getMessage());</span><br><span class=\"line\">                mv = <span class=\"keyword\">new</span> ModelAndView(<span class=\"string\">\"jsonView\"</span>, result.toMap());</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//log日志记录请求的url，打印ex堆栈</span></span><br><span class=\"line\">                log.error(<span class=\"string\">\"unknow json exception, url:\"</span> + url, ex);</span><br><span class=\"line\">                JsonData result = JsonData.fail(defaultMsg);</span><br><span class=\"line\">                mv = <span class=\"keyword\">new</span> ModelAndView(<span class=\"string\">\"jsonView\"</span>, result.toMap());</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (url.endsWith(<span class=\"string\">\".page\"</span>)) &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"unknow page exception, url:\"</span> + url, ex);</span><br><span class=\"line\">            JsonData result = JsonData.fail(defaultMsg);</span><br><span class=\"line\">            mv = <span class=\"keyword\">new</span> ModelAndView(<span class=\"string\">\"exception\"</span>, result.toMap());</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            log.error(<span class=\"string\">\"unknow exception, url:\"</span> + url, ex);</span><br><span class=\"line\">            JsonData result = JsonData.fail(defaultMsg);</span><br><span class=\"line\">            mv = <span class=\"keyword\">new</span> ModelAndView(<span class=\"string\">\"jsonView\"</span>, result.toMap());</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> mv;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details></li>\n</ul>\n<br>\n\n<ul>\n<li>在spring-servlet.xml中添加这个bean<details>\n<summary><font color=\"darkred\">[展示代码]</font></summary>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&lt;!-- 全局异常处理类 --&gt;</span><br><span class=\"line\">&lt;bean <span class=\"class\"><span class=\"keyword\">class</span></span>=<span class=\"string\">\"com.jjstore.common.SpringExceptionResolver\"</span> /&gt;</span><br></pre></td></tr></table></figure>\n\n</details></li>\n</ul>\n<br>","slug":"Spring全局异常拦截及公共响应对象的实现","updated":"2019-07-22T08:06:02.385Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/22/Spring全局异常拦截及公共响应对象的实现/","excerpt":"SpringMVC的三种全局异常拦截处理方式 使用SpringMVC提供的简单异常处理器SimpleMappingExceptionResolver 实现Spring的异常处理接口HandleExceptionResolver 使用@ExceptionHandler注解 公共响应对象的封装 JsonData类封装了一个通用的返回结构，并不具备拦截器功能。 [展示代码] 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455package com.jjstore.common;import lombok.Getter;import lombok.Setter;import java.util.HashMap;import java.util.Map;/** * 定义接口json数据返回的结构 */@Getter@Setterpublic class JsonData &#123; private boolean ret; //返回结果 private String msg; //提示信息 private Object data; //返回的数据 public JsonData(boolean ret) &#123; this.ret = ret; &#125; public static JsonData success(Object object, String msg) &#123; JsonData jsonData = new JsonData(true); jsonData.msg = msg; jsonData.data = object; return jsonData; &#125; public static JsonData success(Object object) &#123; JsonData jsonData = new JsonData(true); jsonData.data = object; return jsonData; &#125; public static JsonData success() &#123; return new JsonData(true); &#125; public static JsonData fail(String msg) &#123; JsonData jsonData = new JsonData(false); jsonData.msg = msg; return jsonData; &#125; public Map&lt;String, Object&gt; toMap() &#123; HashMap&lt;String, Object&gt; result = new HashMap&lt;&gt;(); result.put(\"ret\", ret); result.put(\"msg\", msg); result.put(\"data\", data); return result; &#125;&#125;","categories":[{"name":"projects","slug":"projects","permalink":"https://nojejesus.github.io/techTube/categories/projects/"},{"name":"permission","slug":"projects/permission","permalink":"https://nojejesus.github.io/techTube/categories/projects/permission/"}],"tags":[]},{"title":"IDEA的使用习惯和小技巧","date":"2019-07-21T01:06:31.000Z","path":"2019/07/21/IDEA的使用习惯和小技巧/","text":"常用快捷键（win）Ctrl + N : 按类名查找Ctrl + D : 复制当前行Ctrl + Y : 删除当前行Ctrl + Shift + N : 按文件名查找Ctrl + Shift + ↑ : 当前行向上移Ctrl + Shift + ↓ : 当前行向下移 Ctrl + F12 : 当前类文件结构（域，方法）Alt + Insert : Generate代码生成器Ctrl + Alt + T : Surround With","raw":"---\ntitle: IDEA的使用习惯和小技巧\ndate: 2019-07-21 09:06:31\ntags: \n- IDEA\ncategories: \n- 日常工具\n---\n### 常用快捷键（win）\nCtrl + N : 按类名查找\nCtrl + D : 复制当前行\nCtrl + Y : 删除当前行\nCtrl + Shift + N : 按文件名查找\nCtrl + Shift + ↑ : 当前行向上移\nCtrl + Shift + ↓ : 当前行向下移\n\nCtrl + F12 : 当前类文件结构（域，方法）\nAlt + Insert : Generate代码生成器\nCtrl + Alt + T : Surround With\n\n<!-- more -->\n","content":"<h3 id=\"常用快捷键（win）\"><a href=\"#常用快捷键（win）\" class=\"headerlink\" title=\"常用快捷键（win）\"></a>常用快捷键（win）</h3><p>Ctrl + N : 按类名查找<br>Ctrl + D : 复制当前行<br>Ctrl + Y : 删除当前行<br>Ctrl + Shift + N : 按文件名查找<br>Ctrl + Shift + ↑ : 当前行向上移<br>Ctrl + Shift + ↓ : 当前行向下移</p>\n<p>Ctrl + F12 : 当前类文件结构（域，方法）<br>Alt + Insert : Generate代码生成器<br>Ctrl + Alt + T : Surround With</p>\n<a id=\"more\"></a>\n","slug":"IDEA的使用习惯和小技巧","updated":"2019-07-21T04:08:48.479Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/21/IDEA的使用习惯和小技巧/","excerpt":"常用快捷键（win）Ctrl + N : 按类名查找Ctrl + D : 复制当前行Ctrl + Y : 删除当前行Ctrl + Shift + N : 按文件名查找Ctrl + Shift + ↑ : 当前行向上移Ctrl + Shift + ↓ : 当前行向下移 Ctrl + F12 : 当前类文件结构（域，方法）Alt + Insert : Generate代码生成器Ctrl + Alt + T : Surround With","categories":[{"name":"日常工具","slug":"日常工具","permalink":"https://nojejesus.github.io/techTube/categories/日常工具/"}],"tags":[{"name":"IDEA","slug":"IDEA","permalink":"https://nojejesus.github.io/techTube/tags/IDEA/"}]},{"title":"企业级权限管理系统-部门模块","date":"2019-07-21T00:50:31.000Z","path":"2019/07/21/企业级权限管理系统-部门模块/","text":"新增部门接口开发 IDEA分屏模式在IDEA标签页右键可选择”Split Vertically”或”Split Horizontally”进行横向分屏或垂向分屏模式。 param包（vo层）下创建DeptParam类（部门的vo类），添加lombok注解@ToString。controller包下创建SysDeptController类；service包下创建SysDeptService类；util包下创建LevelUtil工具类（计算部门的层级）。 分层结构本次并没采用上次商城demo的controller + (service interface + service implement) + dao结构，而是基本的controller + service + dao；首先后者这个基本分层是应该要有的，对于service interface + service implement这样设计本身没有严格要求，但细分出接口+接口实现有一些特殊好处，比如service要做成RPC服务，直接将service的interface暴露出去就可以了。 代码 model包为pojo层，SysDept类（部门pojo类）添加lombok注解@Builder，使得Sysdept类通过builder()方法创建实例对象。service层实现新增部门业务逻辑： [展示代码] 12345678910111213/** * @Sysdept 部门pojo类 * @deptParam controller层传入部门对象 * @dept service层vo对象*/SysDept dept = SysDept.builder() .name(deptParam.getName()) .parentId(deptParam.getParentId()) .seq(deptParam.getSeq()) .remark(deptParam.getRemark()) .build();//dept层级dept.setLevel(LevelUtil.calculateLevel(getLevel(deptParam.getParentId()), deptParam.getParentId())); 计算部门层级的工具类 [展示代码] 123456789101112131415161718192021public class LevelUtil &#123; private static final String SEPARATOR = \".\"; private static final String ROOT = \"0\"; //例如 //0 //0.1 //0.1.2 //0.1.3 //0.4 //根据parentId查询parentLevel, 然后拼接parentId得到当前部门所在层级 public static String calculateLevel(String parentLevel, int parentId) &#123; if (StringUtils.isBlank(parentLevel)) &#123; return ROOT; &#125; else &#123; return StringUtils.join(parentLevel, SEPARATOR, parentId); &#125; &#125;&#125; 有选择地更新部门字段，新增部门 [展示代码] 12//只对有值的字段插入，没有值的字段不做处理，也不触发NotNull因素sysDeptMapper.insertSelective(dept); controller层直接调用service层业务逻辑并返回响应结果 [展示代码] 123456@RequestMapping(\"save.json\")@ResponseBodypublic JsonData saveDept(DeptParam deptParam) &#123; sysDeptService.save(deptParam); return JsonData.success();&#125; 部门层级树接口开发com.google.common.collect.MultimapGoogle Guava（Java库）中的表示键值对映射关系的集合，与Map类似，但是Multimap中的键值对可以是一对一关系，也可以一对多关系。创建一个表示层级和该层级所含部门对象的映射集合: 123//层级和属于该层级的部门的映射关系//level -&gt; [dept1, dept2, dept3, ...]Multimap&lt;String, DeptLevelDto&gt; levelDeptMap = ArrayListMultimap.create(); java.util.Collections.sort()方法源码: 123public static &lt;T&gt; void sort(List&lt;T&gt; list, Comparator&lt;? super T&gt; c) &#123; list.sort(c);&#125; java.util.Comparator能对对象集合进行总排序的接口（比较器）。可以将比较器传递给一个排序方法，如: 123Collections.sort(List, Comparator)或者Arrays.sort(Object[], Comparator) 实现明确的排序次序。对于任意元素e1、e2，当且仅当e1.equals(e2)==0，才认为布尔值相同，那么c.compare(e1, e2)==0；rootList是DeptLevelDto类对象的集合，通过比较DeptLevelDto类对象的seq域对rootList的元素进行排序： 1234567//排序规则，从小到大Collections.sort(rootList, new Comparator&lt;DeptLevelDto&gt;() &#123; @Override public int compare(DeptLevelDto o1, DeptLevelDto o2) &#123; return o1.getSeq() - o2.getSeq(); &#125;&#125;); Comparator接口具有方法: 1int compare(T o1, T o2); 返回一个负数，0或正数，分别表示第一个参数小于，等于或大于第二个参数。 递归生成部门树的方法1234567891011121314151617181920212223//递归生成树方法(层级a下所有部门|所有子部门集合，层级a，已按层级-部门做归类映射的所有部门|所有子部门集合)//level:0, 0, all 0 -&gt; 0.1, 0.2//level:0.1//level:0.2public void transformDeptTree(List&lt;DeptLevelDto&gt; deptLevelDtoList, String level, Multimap&lt;String, DeptLevelDto&gt; levelDeptMap) &#123; //遍历每个部门 for (int i = 0; i &lt; deptLevelDtoList.size(); i++) &#123; DeptLevelDto deptLevelDto = deptLevelDtoList.get(i); //处理当前部门的数据 //子部门的层级 String nextLevel = LevelUtil.calculateLevel(level, deptLevelDto.getId()); //获取子部门 List&lt;DeptLevelDto&gt; tempDeptList = (List&lt;DeptLevelDto&gt;) levelDeptMap.get(nextLevel); if (CollectionUtils.isNotEmpty(tempDeptList)) &#123; //排序 Collections.sort(tempDeptList, deptSeqComparator); //设置下一层部门，即将排好序的子部门挂在当前部门下 deptLevelDto.setDeptLevelDtoList(tempDeptList); //进入子部门的下一层处理 transformDeptTree(tempDeptList, nextLevel, levelDeptMap); &#125; &#125;&#125; 更新部门接口开发代码 [展示代码] 1234567891011121314151617181920212223242526272829303132333435363738//更新部门时，目标部门进行了更新则子孙部门也会随之更新，要么都更新成功，要么都失败，所以添加事务注解@Transactionalpublic void updateWithChild(SysDept before, SysDept after) &#123; String newLevelPrefix = after.getLevel(); String oldLevelPrefix = before.getLevel(); if (!newLevelPrefix.equals(oldLevelPrefix)) &#123; //子部门原来层级 String curLevel = before.getLevel() + \".\" + before.getId(); //查询原来的子孙部门 //注意的点：getChildDeptListByLevel()方法可能取出多余的内容吗？ //比如：0.1*查询时可能取出0.1, 0.1.3, 0.11.3，但我们实际并不需要0.11.3这种结果 //在数据库尝试模糊查询\"0.1.%\"与\"0.1%\"，看看是否有区别 List&lt;SysDept&gt; deptList = sysDeptMapper.getChildDeptListByLevel(curLevel + \"%\"); //子孙部门不为空时，做逻辑处理 if (CollectionUtils.isNotEmpty(deptList)) &#123; //遍历子孙部门 for (SysDept dept : deptList) &#123; //子孙部门原来的层级 String level = dept.getLevel(); //逻辑：由于在数据库表设计中，每个部门的level字段其实是上级id的集合，形式例如\"0.2.1.3\" //所以，当某个部门在前端页面被改变了层级，就是部门的parentId发生改变， //而对于这个部门的所有子部门的level字段的值，变化的就是前段。 if (level.equals(curLevel) || level.indexOf(curLevel + \".\") == 0) &#123; //子部门的层级level的值变化: = 被更新部门更新后的层级 + 截取原来层级的后段 //待定： //level = newLevelPrefix + \".\" + dept.getId() + \".\" + level.substring(oldLevelPrefix.length()); level = newLevelPrefix + level.substring(oldLevelPrefix.length()); dept.setLevel(level); &#125; &#125; //批量(子孙部门)更新 sysDeptMapper.batchUpdateLevel(deptList); &#125; &#125; //更新目标部门 sysDeptMapper.updateByPrimaryKey(after);&#125; 注意的点 如果一个类不覆写toString()方法，直接打印这个类时调用的是Object里的toString()，实现苦涩难懂，输出与hashCode有关，实际中我们期望打印的是该类的实例的相关变量值，在类上添加lombok注解@ToString相当于覆写了toString()方法，输出内容是基于变量组成的字符串，容易读懂。 部门表的level这个字段其实就是父级id的集合。这样设计的思考是：如果查询某部门下所有的子部门，就不需要进行递归查询，只需要使用（当前部门层级+当前部门id）作为前缀查询就可。 dto，数据传输对象。本项目中的作用vo-&gt;dto-&gt;pojo-&gt;entity，作用于展示层和服务层的数据传输。 尽管DeptParam与SysDept比较像，但从设计上它们属于两个层面的内容，DeptParam说白了就是封装前端的参数，后面如果处理它是不关心的。这样带来的好处是，数据库有什么调整前端不需要感知。尽管有时候使用SysDept对象去接收前端参数也能完成一些接口的开发，但是这样会造成扩展性很差，同时也相当于把数据库设计暴露给前端了。另外对于数据对象如果引用了其他对象的情况，参数如何传递也是一个大问题，这种情况如果在做一些升级，比如1对1关系，变成1对多关系，前端就直接无法做兼容调整了，后端做字段调整时可能直接带来前端访问错误。但理论上任何一个表的字段都可能调整多次，这就属于无形间增加了数据库调整时的复杂度。只有各个层之间做到真正分离，任何一层需要修改时只需修改层与层之间的适配即可，正常的项目就应该这样去设计。","raw":"---\ntitle: 企业级权限管理系统-部门模块\ndate: 2019-07-21 08:50:31\ntags:\ncategories:\n- projects #一级分类\n- permission #二级分类\n---\n## 新增部门接口开发\n- IDEA分屏模式\n  在IDEA标签页右键可选择\"Split Vertically\"或\"Split Horizontally\"进行横向分屏或垂向分屏模式。\n+ param包（vo层）下创建DeptParam类（部门的vo类），添加lombok注解@ToString。\n  controller包下创建SysDeptController类；\n  service包下创建SysDeptService类；\n  util包下创建LevelUtil工具类（计算部门的层级）。\n<!-- more -->\n- 分层结构\n  本次并没采用上次商城demo的controller + (service interface + service implement) + dao结构，而是基本的controller + service + dao；\n  首先后者这个基本分层是应该要有的，对于service interface + service implement这样设计本身没有严格要求，但细分出接口+接口实现有一些特殊好处，比如service要做成RPC服务，直接将service的interface暴露出去就可以了。\n\n### 代码\n\n1. model包为pojo层，SysDept类（部门pojo类）添加lombok注解@Builder，使得Sysdept类通过builder()方法创建实例对象。service层实现新增部门业务逻辑：\n    <details>\n    <summary><font color=darkred>[展示代码]</font></summary>\n    ```java\n    /**\n     * @Sysdept 部门pojo类\n     * @deptParam controller层传入部门对象\n     * @dept service层vo对象\n    */\n    SysDept dept = SysDept.builder()\n            .name(deptParam.getName())\n            .parentId(deptParam.getParentId())\n            .seq(deptParam.getSeq())\n            .remark(deptParam.getRemark())\n            .build();\n    //dept层级\n    dept.setLevel(LevelUtil.calculateLevel(getLevel(deptParam.getParentId()), deptParam.getParentId()));\n    ```\n    </details><br>\n\n2. 计算部门层级的工具类\n    <details>\n    <summary><font color=darkred>[展示代码]</font></summary>\n    ```java\n    public class LevelUtil {\n\n        private static final String SEPARATOR = \".\";\n        private static final String ROOT = \"0\";\n\n        //例如\n        //0\n        //0.1\n        //0.1.2\n        //0.1.3\n        //0.4\n        //根据parentId查询parentLevel, 然后拼接parentId得到当前部门所在层级\n        public static String calculateLevel(String parentLevel, int parentId) {\n            if (StringUtils.isBlank(parentLevel)) {\n                return ROOT;\n            } else {\n                return StringUtils.join(parentLevel, SEPARATOR, parentId);\n            }\n        }\n\n    }\n    ```\n    </details><br>\n\n3. 有选择地更新部门字段，新增部门\n    <details>\n    <summary><font color=darkred>[展示代码]</font></summary>\n    ```java\n    //只对有值的字段插入，没有值的字段不做处理，也不触发NotNull因素\n    sysDeptMapper.insertSelective(dept);\n    ```\n    </details><br>\n\n4. controller层直接调用service层业务逻辑并返回响应结果\n    <details>\n    <summary><font color=darkred>[展示代码]</font></summary>\n    ```java\n    @RequestMapping(\"save.json\")\n    @ResponseBody\n    public JsonData saveDept(DeptParam deptParam) {\n        sysDeptService.save(deptParam);\n        return JsonData.success();\n    }\n    ```\n    </details><br>\n\n## 部门层级树接口开发\n\n### com.google.common.collect.Multimap\nGoogle Guava（Java库）中的表示键值对映射关系的集合，与Map类似，但是Multimap中的键值对可以是一对一关系，也可以一对多关系。\n创建一个表示层级和该层级所含部门对象的映射集合:\n```java\n//层级和属于该层级的部门的映射关系\n//level -> [dept1, dept2, dept3, ...]\nMultimap<String, DeptLevelDto> levelDeptMap = ArrayListMultimap.create();\n```\n\n### java.util.Collections.sort()\n方法源码:  \n```java\npublic static <T> void sort(List<T> list, Comparator<? super T> c) {\n    list.sort(c);\n}\n```\n\n### java.util.Comparator  \n能对对象集合进行总排序的接口（比较器）。可以将比较器传递给一个排序方法，如:  \n```java\nCollections.sort(List, Comparator)\n或者\nArrays.sort(Object[], Comparator)\n```\n实现明确的排序次序。对于任意元素e1、e2，当且仅当e1.equals(e2)==0，才认为布尔值相同，那么c.compare(e1, e2)==0；rootList是DeptLevelDto类对象的集合，通过比较DeptLevelDto类对象的seq域对rootList的元素进行排序：  \n```java\n//排序规则，从小到大\nCollections.sort(rootList, new Comparator<DeptLevelDto>() {\n    @Override\n    public int compare(DeptLevelDto o1, DeptLevelDto o2) {\n        return o1.getSeq() - o2.getSeq();\n    }\n});\n```\nComparator接口具有方法:\n```java\nint compare(T o1, T o2);\n```\n返回一个负数，0或正数，分别表示第一个参数小于，等于或大于第二个参数。\n\n### 递归生成部门树的方法\n```java\n//递归生成树方法(层级a下所有部门|所有子部门集合，层级a，已按层级-部门做归类映射的所有部门|所有子部门集合)\n//level:0, 0, all   0 -> 0.1, 0.2\n//level:0.1\n//level:0.2\npublic void transformDeptTree(List<DeptLevelDto> deptLevelDtoList, String level, Multimap<String, DeptLevelDto> levelDeptMap) {\n    //遍历每个部门\n    for (int i = 0; i < deptLevelDtoList.size(); i++) {\n        DeptLevelDto deptLevelDto = deptLevelDtoList.get(i);\n        //处理当前部门的数据\n        //子部门的层级\n        String nextLevel = LevelUtil.calculateLevel(level, deptLevelDto.getId());\n        //获取子部门\n        List<DeptLevelDto> tempDeptList = (List<DeptLevelDto>) levelDeptMap.get(nextLevel);\n        if (CollectionUtils.isNotEmpty(tempDeptList)) {\n            //排序\n            Collections.sort(tempDeptList, deptSeqComparator);\n            //设置下一层部门，即将排好序的子部门挂在当前部门下\n            deptLevelDto.setDeptLevelDtoList(tempDeptList);\n            //进入子部门的下一层处理\n            transformDeptTree(tempDeptList, nextLevel, levelDeptMap);\n        }\n    }\n}\n```\n\n---\n\n## 更新部门接口开发\n\n### 代码\n<details>\n<summary><font color=darkred>[展示代码]</font></summary>\n\n```java\n//更新部门时，目标部门进行了更新则子孙部门也会随之更新，要么都更新成功，要么都失败，所以添加事务注解\n@Transactional\npublic void updateWithChild(SysDept before, SysDept after) {\n\n    String newLevelPrefix = after.getLevel();\n    String oldLevelPrefix = before.getLevel();\n    if (!newLevelPrefix.equals(oldLevelPrefix)) {\n        //子部门原来层级\n        String curLevel = before.getLevel() + \".\" + before.getId();\n        //查询原来的子孙部门\n        //注意的点：getChildDeptListByLevel()方法可能取出多余的内容吗？\n        //比如：0.1*查询时可能取出0.1, 0.1.3, 0.11.3，但我们实际并不需要0.11.3这种结果\n        //在数据库尝试模糊查询\"0.1.%\"与\"0.1%\"，看看是否有区别\n        List<SysDept> deptList = sysDeptMapper.getChildDeptListByLevel(curLevel + \"%\");\n        //子孙部门不为空时，做逻辑处理\n        if (CollectionUtils.isNotEmpty(deptList)) {\n            //遍历子孙部门\n            for (SysDept dept : deptList) {\n                //子孙部门原来的层级\n                String level = dept.getLevel();\n                //逻辑：由于在数据库表设计中，每个部门的level字段其实是上级id的集合，形式例如\"0.2.1.3\"\n                //所以，当某个部门在前端页面被改变了层级，就是部门的parentId发生改变，\n                //而对于这个部门的所有子部门的level字段的值，变化的就是前段。\n                if (level.equals(curLevel) || level.indexOf(curLevel + \".\") == 0) {\n                    //子部门的层级level的值变化: = 被更新部门更新后的层级 + 截取原来层级的后段\n                    //待定：\n                    //level = newLevelPrefix + \".\" + dept.getId() + \".\" + level.substring(oldLevelPrefix.length());\n                    level = newLevelPrefix + level.substring(oldLevelPrefix.length());\n                    dept.setLevel(level);\n                }\n            }\n            //批量(子孙部门)更新\n            sysDeptMapper.batchUpdateLevel(deptList);\n        }\n    }\n    //更新目标部门\n    sysDeptMapper.updateByPrimaryKey(after);\n}\n```\n\n</details>\n\n## 注意的点\n1. 如果一个类不覆写toString()方法，直接打印这个类时调用的是Object里的toString()，实现苦涩难懂，输出与hashCode有关，实际中我们期望打印的是该类的实例的相关变量值，在类上添加lombok注解@ToString相当于覆写了toString()方法，输出内容是基于变量组成的字符串，容易读懂。\n2. 部门表的level这个字段其实就是父级id的集合。这样设计的思考是：如果查询某部门下所有的子部门，就不需要进行递归查询，只需要使用（当前部门层级+当前部门id）作为前缀查询就可。\n3. dto，数据传输对象。本项目中的作用vo->dto->pojo->entity，作用于展示层和服务层的数据传输。\n4. 尽管DeptParam与SysDept比较像，但从设计上它们属于两个层面的内容，DeptParam说白了就是封装前端的参数，后面如果处理它是不关心的。这样带来的好处是，数据库有什么调整前端不需要感知。尽管有时候使用SysDept对象去接收前端参数也能完成一些接口的开发，但是这样会造成扩展性很差，同时也相当于把数据库设计暴露给前端了。另外对于数据对象如果引用了其他对象的情况，参数如何传递也是一个大问题，这种情况如果在做一些升级，比如1对1关系，变成1对多关系，前端就直接无法做兼容调整了，后端做字段调整时可能直接带来前端访问错误。但理论上任何一个表的字段都可能调整多次，这就属于无形间增加了数据库调整时的复杂度。只有各个层之间做到真正分离，任何一层需要修改时只需修改层与层之间的适配即可，正常的项目就应该这样去设计。","content":"<h2 id=\"新增部门接口开发\"><a href=\"#新增部门接口开发\" class=\"headerlink\" title=\"新增部门接口开发\"></a>新增部门接口开发</h2><ul>\n<li>IDEA分屏模式<br>在IDEA标签页右键可选择”Split Vertically”或”Split Horizontally”进行横向分屏或垂向分屏模式。</li>\n</ul>\n<ul>\n<li>param包（vo层）下创建DeptParam类（部门的vo类），添加lombok注解@ToString。<br>controller包下创建SysDeptController类；<br>service包下创建SysDeptService类；<br>util包下创建LevelUtil工具类（计算部门的层级）。<a id=\"more\"></a></li>\n</ul>\n<ul>\n<li>分层结构<br>本次并没采用上次商城demo的controller + (service interface + service implement) + dao结构，而是基本的controller + service + dao；<br>首先后者这个基本分层是应该要有的，对于service interface + service implement这样设计本身没有严格要求，但细分出接口+接口实现有一些特殊好处，比如service要做成RPC服务，直接将service的interface暴露出去就可以了。</li>\n</ul>\n<h3 id=\"代码\"><a href=\"#代码\" class=\"headerlink\" title=\"代码\"></a>代码</h3><ol>\n<li><p>model包为pojo层，SysDept类（部门pojo类）添加lombok注解@Builder，使得Sysdept类通过builder()方法创建实例对象。service层实现新增部门业务逻辑：</p>\n <details>\n <summary><font color=\"darkred\">[展示代码]</font></summary>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@Sysdept</span> 部门pojo类</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@deptParam</span> controller层传入部门对象</span></span><br><span class=\"line\"><span class=\"comment\"> * <span class=\"doctag\">@dept</span> service层vo对象</span></span><br><span class=\"line\"><span class=\"comment\">*/</span></span><br><span class=\"line\">SysDept dept = SysDept.builder()</span><br><span class=\"line\">        .name(deptParam.getName())</span><br><span class=\"line\">        .parentId(deptParam.getParentId())</span><br><span class=\"line\">        .seq(deptParam.getSeq())</span><br><span class=\"line\">        .remark(deptParam.getRemark())</span><br><span class=\"line\">        .build();</span><br><span class=\"line\"><span class=\"comment\">//dept层级</span></span><br><span class=\"line\">dept.setLevel(LevelUtil.calculateLevel(getLevel(deptParam.getParentId()), deptParam.getParentId()));</span><br></pre></td></tr></table></figure>\n\n </details><br>\n</li>\n<li><p>计算部门层级的工具类</p>\n <details>\n <summary><font color=\"darkred\">[展示代码]</font></summary>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">LevelUtil</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String SEPARATOR = <span class=\"string\">\".\"</span>;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> String ROOT = <span class=\"string\">\"0\"</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//例如</span></span><br><span class=\"line\">    <span class=\"comment\">//0</span></span><br><span class=\"line\">    <span class=\"comment\">//0.1</span></span><br><span class=\"line\">    <span class=\"comment\">//0.1.2</span></span><br><span class=\"line\">    <span class=\"comment\">//0.1.3</span></span><br><span class=\"line\">    <span class=\"comment\">//0.4</span></span><br><span class=\"line\">    <span class=\"comment\">//根据parentId查询parentLevel, 然后拼接parentId得到当前部门所在层级</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">calculateLevel</span><span class=\"params\">(String parentLevel, <span class=\"keyword\">int</span> parentId)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (StringUtils.isBlank(parentLevel)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> ROOT;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> StringUtils.join(parentLevel, SEPARATOR, parentId);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n </details><br>\n</li>\n<li><p>有选择地更新部门字段，新增部门</p>\n <details>\n <summary><font color=\"darkred\">[展示代码]</font></summary>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//只对有值的字段插入，没有值的字段不做处理，也不触发NotNull因素</span></span><br><span class=\"line\">sysDeptMapper.insertSelective(dept);</span><br></pre></td></tr></table></figure>\n\n </details><br>\n</li>\n<li><p>controller层直接调用service层业务逻辑并返回响应结果</p>\n <details>\n <summary><font color=\"darkred\">[展示代码]</font></summary>\n <figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@RequestMapping</span>(<span class=\"string\">\"save.json\"</span>)</span><br><span class=\"line\"><span class=\"meta\">@ResponseBody</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> JsonData <span class=\"title\">saveDept</span><span class=\"params\">(DeptParam deptParam)</span> </span>&#123;</span><br><span class=\"line\">    sysDeptService.save(deptParam);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> JsonData.success();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n </details><br>\n\n</li>\n</ol>\n<h2 id=\"部门层级树接口开发\"><a href=\"#部门层级树接口开发\" class=\"headerlink\" title=\"部门层级树接口开发\"></a>部门层级树接口开发</h2><h3 id=\"com-google-common-collect-Multimap\"><a href=\"#com-google-common-collect-Multimap\" class=\"headerlink\" title=\"com.google.common.collect.Multimap\"></a>com.google.common.collect.Multimap</h3><p>Google Guava（Java库）中的表示键值对映射关系的集合，与Map类似，但是Multimap中的键值对可以是一对一关系，也可以一对多关系。<br>创建一个表示层级和该层级所含部门对象的映射集合:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//层级和属于该层级的部门的映射关系</span></span><br><span class=\"line\"><span class=\"comment\">//level -&gt; [dept1, dept2, dept3, ...]</span></span><br><span class=\"line\">Multimap&lt;String, DeptLevelDto&gt; levelDeptMap = ArrayListMultimap.create();</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"java-util-Collections-sort\"><a href=\"#java-util-Collections-sort\" class=\"headerlink\" title=\"java.util.Collections.sort()\"></a>java.util.Collections.sort()</h3><p>方法源码:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> &lt;T&gt; <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">sort</span><span class=\"params\">(List&lt;T&gt; list, Comparator&lt;? <span class=\"keyword\">super</span> T&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    list.sort(c);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"java-util-Comparator\"><a href=\"#java-util-Comparator\" class=\"headerlink\" title=\"java.util.Comparator\"></a>java.util.Comparator</h3><p>能对对象集合进行总排序的接口（比较器）。可以将比较器传递给一个排序方法，如:  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">Collections.sort(List, Comparator)</span><br><span class=\"line\">或者</span><br><span class=\"line\">Arrays.sort(Object[], Comparator)</span><br></pre></td></tr></table></figure>\n\n<p>实现明确的排序次序。对于任意元素e1、e2，当且仅当e1.equals(e2)==0，才认为布尔值相同，那么c.compare(e1, e2)==0；rootList是DeptLevelDto类对象的集合，通过比较DeptLevelDto类对象的seq域对rootList的元素进行排序：  </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//排序规则，从小到大</span></span><br><span class=\"line\">Collections.sort(rootList, <span class=\"keyword\">new</span> Comparator&lt;DeptLevelDto&gt;() &#123;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(DeptLevelDto o1, DeptLevelDto o2)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> o1.getSeq() - o2.getSeq();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;);</span><br></pre></td></tr></table></figure>\n\n<p>Comparator接口具有方法:</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">compare</span><span class=\"params\">(T o1, T o2)</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>返回一个负数，0或正数，分别表示第一个参数小于，等于或大于第二个参数。</p>\n<h3 id=\"递归生成部门树的方法\"><a href=\"#递归生成部门树的方法\" class=\"headerlink\" title=\"递归生成部门树的方法\"></a>递归生成部门树的方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//递归生成树方法(层级a下所有部门|所有子部门集合，层级a，已按层级-部门做归类映射的所有部门|所有子部门集合)</span></span><br><span class=\"line\"><span class=\"comment\">//level:0, 0, all   0 -&gt; 0.1, 0.2</span></span><br><span class=\"line\"><span class=\"comment\">//level:0.1</span></span><br><span class=\"line\"><span class=\"comment\">//level:0.2</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">transformDeptTree</span><span class=\"params\">(List&lt;DeptLevelDto&gt; deptLevelDtoList, String level, Multimap&lt;String, DeptLevelDto&gt; levelDeptMap)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//遍历每个部门</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>; i &lt; deptLevelDtoList.size(); i++) &#123;</span><br><span class=\"line\">        DeptLevelDto deptLevelDto = deptLevelDtoList.get(i);</span><br><span class=\"line\">        <span class=\"comment\">//处理当前部门的数据</span></span><br><span class=\"line\">        <span class=\"comment\">//子部门的层级</span></span><br><span class=\"line\">        String nextLevel = LevelUtil.calculateLevel(level, deptLevelDto.getId());</span><br><span class=\"line\">        <span class=\"comment\">//获取子部门</span></span><br><span class=\"line\">        List&lt;DeptLevelDto&gt; tempDeptList = (List&lt;DeptLevelDto&gt;) levelDeptMap.get(nextLevel);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CollectionUtils.isNotEmpty(tempDeptList)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//排序</span></span><br><span class=\"line\">            Collections.sort(tempDeptList, deptSeqComparator);</span><br><span class=\"line\">            <span class=\"comment\">//设置下一层部门，即将排好序的子部门挂在当前部门下</span></span><br><span class=\"line\">            deptLevelDto.setDeptLevelDtoList(tempDeptList);</span><br><span class=\"line\">            <span class=\"comment\">//进入子部门的下一层处理</span></span><br><span class=\"line\">            transformDeptTree(tempDeptList, nextLevel, levelDeptMap);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<hr>\n<h2 id=\"更新部门接口开发\"><a href=\"#更新部门接口开发\" class=\"headerlink\" title=\"更新部门接口开发\"></a>更新部门接口开发</h2><h3 id=\"代码-1\"><a href=\"#代码-1\" class=\"headerlink\" title=\"代码\"></a>代码</h3><details>\n<summary><font color=\"darkred\">[展示代码]</font></summary>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//更新部门时，目标部门进行了更新则子孙部门也会随之更新，要么都更新成功，要么都失败，所以添加事务注解</span></span><br><span class=\"line\"><span class=\"meta\">@Transactional</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">updateWithChild</span><span class=\"params\">(SysDept before, SysDept after)</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    String newLevelPrefix = after.getLevel();</span><br><span class=\"line\">    String oldLevelPrefix = before.getLevel();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!newLevelPrefix.equals(oldLevelPrefix)) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//子部门原来层级</span></span><br><span class=\"line\">        String curLevel = before.getLevel() + <span class=\"string\">\".\"</span> + before.getId();</span><br><span class=\"line\">        <span class=\"comment\">//查询原来的子孙部门</span></span><br><span class=\"line\">        <span class=\"comment\">//注意的点：getChildDeptListByLevel()方法可能取出多余的内容吗？</span></span><br><span class=\"line\">        <span class=\"comment\">//比如：0.1*查询时可能取出0.1, 0.1.3, 0.11.3，但我们实际并不需要0.11.3这种结果</span></span><br><span class=\"line\">        <span class=\"comment\">//在数据库尝试模糊查询\"0.1.%\"与\"0.1%\"，看看是否有区别</span></span><br><span class=\"line\">        List&lt;SysDept&gt; deptList = sysDeptMapper.getChildDeptListByLevel(curLevel + <span class=\"string\">\"%\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//子孙部门不为空时，做逻辑处理</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (CollectionUtils.isNotEmpty(deptList)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//遍历子孙部门</span></span><br><span class=\"line\">            <span class=\"keyword\">for</span> (SysDept dept : deptList) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//子孙部门原来的层级</span></span><br><span class=\"line\">                String level = dept.getLevel();</span><br><span class=\"line\">                <span class=\"comment\">//逻辑：由于在数据库表设计中，每个部门的level字段其实是上级id的集合，形式例如\"0.2.1.3\"</span></span><br><span class=\"line\">                <span class=\"comment\">//所以，当某个部门在前端页面被改变了层级，就是部门的parentId发生改变，</span></span><br><span class=\"line\">                <span class=\"comment\">//而对于这个部门的所有子部门的level字段的值，变化的就是前段。</span></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (level.equals(curLevel) || level.indexOf(curLevel + <span class=\"string\">\".\"</span>) == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//子部门的层级level的值变化: = 被更新部门更新后的层级 + 截取原来层级的后段</span></span><br><span class=\"line\">                    <span class=\"comment\">//待定：</span></span><br><span class=\"line\">                    <span class=\"comment\">//level = newLevelPrefix + \".\" + dept.getId() + \".\" + level.substring(oldLevelPrefix.length());</span></span><br><span class=\"line\">                    level = newLevelPrefix + level.substring(oldLevelPrefix.length());</span><br><span class=\"line\">                    dept.setLevel(level);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">//批量(子孙部门)更新</span></span><br><span class=\"line\">            sysDeptMapper.batchUpdateLevel(deptList);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//更新目标部门</span></span><br><span class=\"line\">    sysDeptMapper.updateByPrimaryKey(after);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<h2 id=\"注意的点\"><a href=\"#注意的点\" class=\"headerlink\" title=\"注意的点\"></a>注意的点</h2><ol>\n<li>如果一个类不覆写toString()方法，直接打印这个类时调用的是Object里的toString()，实现苦涩难懂，输出与hashCode有关，实际中我们期望打印的是该类的实例的相关变量值，在类上添加lombok注解@ToString相当于覆写了toString()方法，输出内容是基于变量组成的字符串，容易读懂。</li>\n<li>部门表的level这个字段其实就是父级id的集合。这样设计的思考是：如果查询某部门下所有的子部门，就不需要进行递归查询，只需要使用（当前部门层级+当前部门id）作为前缀查询就可。</li>\n<li>dto，数据传输对象。本项目中的作用vo-&gt;dto-&gt;pojo-&gt;entity，作用于展示层和服务层的数据传输。</li>\n<li>尽管DeptParam与SysDept比较像，但从设计上它们属于两个层面的内容，DeptParam说白了就是封装前端的参数，后面如果处理它是不关心的。这样带来的好处是，数据库有什么调整前端不需要感知。尽管有时候使用SysDept对象去接收前端参数也能完成一些接口的开发，但是这样会造成扩展性很差，同时也相当于把数据库设计暴露给前端了。另外对于数据对象如果引用了其他对象的情况，参数如何传递也是一个大问题，这种情况如果在做一些升级，比如1对1关系，变成1对多关系，前端就直接无法做兼容调整了，后端做字段调整时可能直接带来前端访问错误。但理论上任何一个表的字段都可能调整多次，这就属于无形间增加了数据库调整时的复杂度。只有各个层之间做到真正分离，任何一层需要修改时只需修改层与层之间的适配即可，正常的项目就应该这样去设计。</li>\n</ol>\n","slug":"企业级权限管理系统-部门模块","updated":"2019-07-24T11:51:10.610Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/21/企业级权限管理系统-部门模块/","excerpt":"新增部门接口开发 IDEA分屏模式在IDEA标签页右键可选择”Split Vertically”或”Split Horizontally”进行横向分屏或垂向分屏模式。 param包（vo层）下创建DeptParam类（部门的vo类），添加lombok注解@ToString。controller包下创建SysDeptController类；service包下创建SysDeptService类；util包下创建LevelUtil工具类（计算部门的层级）。","categories":[{"name":"projects","slug":"projects","permalink":"https://nojejesus.github.io/techTube/categories/projects/"},{"name":"permission","slug":"projects/permission","permalink":"https://nojejesus.github.io/techTube/categories/projects/permission/"}],"tags":[]},{"title":"数据库和缓存一致性问题","date":"2019-07-20T14:37:55.000Z","path":"2019/07/20/数据库和缓存一致性问题/","text":"DB和缓存同时操作的一致性问题缓存中的数据和数据源并非总是一致的，应用程序必须实现一种帮助确保缓存和数据源一致的策略。这种策略不仅能够确保缓存里的数据是最新的，而且当缓存中的数据不是最新的时候，需要能被监测到并采取响应措施。（待续：https://coding.imooc.com/learn/questiondetail/105625.html）","raw":"---\ntitle: 数据库和缓存一致性问题\ndate: 2019-07-20 22:37:55\ntags:\n- 数据库\n- 缓存\ncategories:\n- 数据库\n---\n##### DB和缓存同时操作的一致性问题\n缓存中的数据和数据源并非总是一致的，应用程序必须实现一种帮助确保缓存和数据源一致的策略。这种策略不仅能够确保缓存里的数据是最新的，而且当缓存中的数据不是最新的时候，需要能被监测到并采取响应措施。\n（待续：https://coding.imooc.com/learn/questiondetail/105625.html）\n<!-- more -->","content":"<h5 id=\"DB和缓存同时操作的一致性问题\"><a href=\"#DB和缓存同时操作的一致性问题\" class=\"headerlink\" title=\"DB和缓存同时操作的一致性问题\"></a>DB和缓存同时操作的一致性问题</h5><p>缓存中的数据和数据源并非总是一致的，应用程序必须实现一种帮助确保缓存和数据源一致的策略。这种策略不仅能够确保缓存里的数据是最新的，而且当缓存中的数据不是最新的时候，需要能被监测到并采取响应措施。<br>（待续：<a href=\"https://coding.imooc.com/learn/questiondetail/105625.html）\" target=\"_blank\" rel=\"noopener\">https://coding.imooc.com/learn/questiondetail/105625.html）</a></p>\n<a id=\"more\"></a>","slug":"数据库和缓存一致性问题","updated":"2019-07-20T14:59:30.889Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/20/数据库和缓存一致性问题/","excerpt":"DB和缓存同时操作的一致性问题缓存中的数据和数据源并非总是一致的，应用程序必须实现一种帮助确保缓存和数据源一致的策略。这种策略不仅能够确保缓存里的数据是最新的，而且当缓存中的数据不是最新的时候，需要能被监测到并采取响应措施。（待续：https://coding.imooc.com/learn/questiondetail/105625.html）","categories":[{"name":"数据库","slug":"数据库","permalink":"https://nojejesus.github.io/techTube/categories/数据库/"}],"tags":[{"name":"数据库","slug":"数据库","permalink":"https://nojejesus.github.io/techTube/tags/数据库/"},{"name":"缓存","slug":"缓存","permalink":"https://nojejesus.github.io/techTube/tags/缓存/"}]},{"title":"多线程并发与线程安全","date":"2019-07-20T04:07:38.000Z","path":"2019/07/20/多线程并发与线程安全/","text":"死锁四个必要条件： 互斥条件 请求和保持条件 不剥夺条件 环路等待条件 例子： [展示代码] 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960/** * 一个简单的死锁类 * 当DeadLock类的对象flag==1时（td1），先锁定o1，睡眠500毫秒， * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2，睡眠500毫秒， * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定， * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定， * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。 */@Slf4jpublic class DeadLock implements Runnable &#123; public int flag = 1; //静态对象是类的所有对象共享的 private static Object o1 = new Object(), o2 = new Object(); @Override public void run() &#123; log.info(\"flag: &#123;&#125;\", flag); if (flag == 1) &#123; //锁o1 synchronized (o1) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //锁o2 synchronized (o2) &#123; log.info(\"1\"); &#125; &#125; &#125; if (flag == 0) &#123; //锁o2 synchronized (o2) &#123; try &#123; Thread.sleep(500); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; //锁o1 synchronized (o1) &#123; log.info(\"0\"); &#125; &#125; &#125; &#125; public static void main(String[] args) &#123; DeadLock td1 = new DeadLock(); DeadLock td2 = new DeadLock(); td1.flag = 1; td2.flag = 0; //td1，td2都处于可执行状态，但是JVM线程调度先先执行哪个线程是不确定的。 //td2的run()可能在td1的run()之前运行。 new Thread(td1).start(); new Thread(td2).start(); &#125;&#125; 避免死锁方法1.加锁顺序，线程要按一定顺序加锁。2.加锁时限，加锁时要限时，超过时限就要放弃对该锁的请求并释放自己占有的锁。如ReentranLock。3.死锁检测，这是个说起来容易做起来难的办法。一般也没人选择这样实现。在实际项目中，如果发生了死锁，往往就要重启项目，这个代价还是非常大的。 Spring与线程安全 Spring Bean: singleton(单例)、prototypeSpring对每个Bean提供了scope属性来表示该Bean之作用域，它是这个Bean的生命周期，singleton对象表示单例对象，在第一次注入时就会被复用到应用结束；prototype类型则在每次注入时都会创建新的对象。 无状态对象由Spring管理的对象其实大多数是无状态对象（不会因为多线程进行线程调度而导致状态被破坏）。包括常用到的dto、vo这些只作为数据实体模型的对象，还有service、dao、controller等等对象。例如每个dao提供的函数，对只是对数据库的crud操作，并且每个数据库的connection都是作为函数的局部变量，用完即关，或者交还连接池。局部变量是在用户栈中，是线程私有的内存区域，所以也不存在线程安全问题。 所以很清楚，Spring对Bean的多线程安全问题并没有做出任何保证或措施，对于每个Bean不存在线程安全问题，根本原因是这些Bean的设计并没有在Bean中声明任何有状态的实例变量或类变量。如果要做有状态设计，那么可以使用ThreadLocal把变量变成线程私有，而如果Bean的实例变量或者类变量需要在多个线程间共享，那就只能使用synchronized、lock、CAS等实现线程同步了。 HashMap与ConcurrentHashMap前者是非线程安全的，后者是线程安全的。前者允许key，value为空，后者则不允许。前者不允许在通过Iterator遍历同时对HashMap修改（例如使用iterator的remove()），而后者是允许的，并且更新后续可见。ConcurrentHashMap是也通过key的哈希值与数组的长度的取模来确定该key在数组中的索引（是不是有点绕），与以往版本不同的是，在Java8里ConcurrentHashMap的实现做了较大调整，取消了segment分段锁而采用CAS和synchronized来保证并发安全，数据结构采用数组+链表/红黑二叉树的方式实现（当链表中的节点个数超过8个时，转换成红黑树的数据结构来存储。synchronized只锁定当前链表或红黑二叉树的首节点），提高了并发性，寻址效率高。(补充一下，1.8HashMap也不再仅仅是数组+链表形式，也有树了) 概念：fast-fail机制即快速失败机制，是java集合（Collection）中的一种错误检测机制。在迭代集合的过程中该集合在结构上发生改变时，就可能发生fast-fail，即抛出ConcurrentModificationException异常。fast-fail机制并不保证在异步修改一定会抛出异常，它只是“尽最大努力”去抛出，所以这种机制一般仅用于检测bug。推荐阅读：http://www.nowamagic.net/librarys/veda/detail/1202 HashMap的存取之美","raw":"---\ntitle: 多线程并发与线程安全\ndate: 2019-07-20 12:07:38\ntags: \n- 多线程\n- 并发\n- 线程安全\ncategories: \n- Java杂谈\n---\n### 死锁\n四个必要条件：\n> - 互斥条件\n> - 请求和保持条件\n> - 不剥夺条件\n> - 环路等待条件\n<!-- more -->\n例子：\n<details>\n<summary><font color=darkred>[展示代码]</font></summary>\n\n```java\n/**\n * 一个简单的死锁类\n * 当DeadLock类的对象flag==1时（td1），先锁定o1，睡眠500毫秒，\n * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2，睡眠500毫秒，\n * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定，\n * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定，\n * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。\n */\n\n@Slf4j\npublic class DeadLock implements Runnable {\n    public int flag = 1;\n    //静态对象是类的所有对象共享的\n    private static Object o1 = new Object(), o2 = new Object();\n\n    @Override\n    public void run() {\n        log.info(\"flag: {}\", flag);\n        if (flag == 1) {\n            //锁o1\n            synchronized (o1) {\n                try {\n                    Thread.sleep(500);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                //锁o2\n                synchronized (o2) {\n                    log.info(\"1\");\n                }\n            }\n        }\n        if (flag == 0) {\n            //锁o2\n            synchronized (o2) {\n                try {\n                    Thread.sleep(500);\n                } catch (Exception e) {\n                    e.printStackTrace();\n                }\n                //锁o1\n                synchronized (o1) {\n                    log.info(\"0\");\n                }\n            }\n        }\n    }\n\n    public static void main(String[] args) {\n        DeadLock td1 = new DeadLock();\n        DeadLock td2 = new DeadLock();\n        td1.flag = 1;\n        td2.flag = 0;\n        //td1，td2都处于可执行状态，但是JVM线程调度先先执行哪个线程是不确定的。\n        //td2的run()可能在td1的run()之前运行。\n        new Thread(td1).start();\n        new Thread(td2).start();\n    }\n\n}\n```\n</details>\n\n#### 避免死锁方法\n1.加锁顺序，线程要按一定顺序加锁。\n2.加锁时限，加锁时要限时，超过时限就要放弃对该锁的请求并释放自己占有的锁。如ReentranLock。\n3.死锁检测，这是个说起来容易做起来难的办法。一般也没人选择这样实现。\n在实际项目中，如果发生了死锁，往往就要重启项目，这个代价还是非常大的。\n\n### Spring与线程安全\n- Spring Bean: singleton(单例)、prototype\nSpring对每个Bean提供了scope属性来表示该Bean之作用域，它是这个Bean的生命周期，singleton对象表示单例对象，在第一次注入时就会被复用到应用结束；prototype类型则在每次注入时都会创建新的对象。\n- 无状态对象\n由Spring管理的对象其实大多数是无状态对象（不会因为多线程进行线程调度而导致状态被破坏）。包括常用到的dto、vo这些只作为数据实体模型的对象，还有service、dao、controller等等对象。例如每个dao提供的函数，对只是对数据库的crud操作，并且每个数据库的connection都是作为函数的局部变量，用完即关，或者交还连接池。\n局部变量是在用户栈中，是线程私有的内存区域，所以也不存在线程安全问题。\n\n所以很清楚，Spring对Bean的多线程安全问题并没有做出任何保证或措施，对于每个Bean不存在线程安全问题，根本原因是这些Bean的设计并没有在Bean中声明任何有状态的实例变量或类变量。如果要做有状态设计，那么可以使用ThreadLocal把变量变成线程私有，而如果Bean的实例变量或者类变量需要在多个线程间共享，那就只能使用synchronized、lock、CAS等实现线程同步了。\n\n### HashMap与ConcurrentHashMap\n前者是非线程安全的，后者是线程安全的。\n前者允许key，value为空，后者则不允许。\n前者不允许在通过Iterator遍历同时对HashMap修改（例如使用iterator的remove()），而后者是允许的，并且更新后续可见。\nConcurrentHashMap是也通过key的哈希值与数组的长度的取模来确定该key在数组中的索引（是不是有点绕），与以往版本不同的是，在Java8里ConcurrentHashMap的实现做了较大调整，取消了segment分段锁而采用CAS和synchronized来保证并发安全，数据结构采用数组+链表/红黑二叉树的方式实现（当链表中的节点个数超过8个时，转换成红黑树的数据结构来存储。synchronized只锁定当前链表或红黑二叉树的首节点），提高了并发性，寻址效率高。(补充一下，1.8HashMap也不再仅仅是数组+链表形式，也有树了)\n#### 概念：fast-fail机制\n即快速失败机制，是java集合（Collection）中的一种错误检测机制。在迭代集合的过程中该集合在结构上发生改变时，就可能发生fast-fail，即抛出ConcurrentModificationException异常。fast-fail机制并不保证在异步修改一定会抛出异常，它只是“尽最大努力”去抛出，所以这种机制一般仅用于检测bug。\n推荐阅读：http://www.nowamagic.net/librarys/veda/detail/1202 HashMap的存取之美","content":"<h3 id=\"死锁\"><a href=\"#死锁\" class=\"headerlink\" title=\"死锁\"></a>死锁</h3><p>四个必要条件：</p>\n<blockquote>\n<ul>\n<li>互斥条件</li>\n<li>请求和保持条件</li>\n<li>不剥夺条件</li>\n<li>环路等待条件</li>\n</ul>\n</blockquote>\n<a id=\"more\"></a>\n<p>例子：</p>\n<details>\n<summary><font color=\"darkred\">[展示代码]</font></summary>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * 一个简单的死锁类</span></span><br><span class=\"line\"><span class=\"comment\"> * 当DeadLock类的对象flag==1时（td1），先锁定o1，睡眠500毫秒，</span></span><br><span class=\"line\"><span class=\"comment\"> * 而td1在睡眠的时候另一个flag==0的对象（td2）线程启动，先锁定o2，睡眠500毫秒，</span></span><br><span class=\"line\"><span class=\"comment\"> * td1睡眠结束后需要锁定o2才能继续执行，而此时o2已被td2锁定，</span></span><br><span class=\"line\"><span class=\"comment\"> * td2睡眠结束后需要锁定o1才能继续执行，而此时o1已被td1锁定，</span></span><br><span class=\"line\"><span class=\"comment\"> * td1、td2相互等待，都需要得到对方锁定的资源才能继续执行，从而死锁。</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Slf</span>4j</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DeadLock</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">public</span> <span class=\"keyword\">int</span> flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">//静态对象是类的所有对象共享的</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Object o1 = <span class=\"keyword\">new</span> Object(), o2 = <span class=\"keyword\">new</span> Object();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        log.info(<span class=\"string\">\"flag: &#123;&#125;\"</span>, flag);</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag == <span class=\"number\">1</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//锁o1</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (o1) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//锁o2</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (o2) &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">\"1\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (flag == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//锁o2</span></span><br><span class=\"line\">            <span class=\"keyword\">synchronized</span> (o2) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    Thread.sleep(<span class=\"number\">500</span>);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    e.printStackTrace();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"comment\">//锁o1</span></span><br><span class=\"line\">                <span class=\"keyword\">synchronized</span> (o1) &#123;</span><br><span class=\"line\">                    log.info(<span class=\"string\">\"0\"</span>);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        DeadLock td1 = <span class=\"keyword\">new</span> DeadLock();</span><br><span class=\"line\">        DeadLock td2 = <span class=\"keyword\">new</span> DeadLock();</span><br><span class=\"line\">        td1.flag = <span class=\"number\">1</span>;</span><br><span class=\"line\">        td2.flag = <span class=\"number\">0</span>;</span><br><span class=\"line\">        <span class=\"comment\">//td1，td2都处于可执行状态，但是JVM线程调度先先执行哪个线程是不确定的。</span></span><br><span class=\"line\">        <span class=\"comment\">//td2的run()可能在td1的run()之前运行。</span></span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(td1).start();</span><br><span class=\"line\">        <span class=\"keyword\">new</span> Thread(td2).start();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n</details>\n\n<h4 id=\"避免死锁方法\"><a href=\"#避免死锁方法\" class=\"headerlink\" title=\"避免死锁方法\"></a>避免死锁方法</h4><p>1.加锁顺序，线程要按一定顺序加锁。<br>2.加锁时限，加锁时要限时，超过时限就要放弃对该锁的请求并释放自己占有的锁。如ReentranLock。<br>3.死锁检测，这是个说起来容易做起来难的办法。一般也没人选择这样实现。<br>在实际项目中，如果发生了死锁，往往就要重启项目，这个代价还是非常大的。</p>\n<h3 id=\"Spring与线程安全\"><a href=\"#Spring与线程安全\" class=\"headerlink\" title=\"Spring与线程安全\"></a>Spring与线程安全</h3><ul>\n<li>Spring Bean: singleton(单例)、prototype<br>Spring对每个Bean提供了scope属性来表示该Bean之作用域，它是这个Bean的生命周期，singleton对象表示单例对象，在第一次注入时就会被复用到应用结束；prototype类型则在每次注入时都会创建新的对象。</li>\n<li>无状态对象<br>由Spring管理的对象其实大多数是无状态对象（不会因为多线程进行线程调度而导致状态被破坏）。包括常用到的dto、vo这些只作为数据实体模型的对象，还有service、dao、controller等等对象。例如每个dao提供的函数，对只是对数据库的crud操作，并且每个数据库的connection都是作为函数的局部变量，用完即关，或者交还连接池。<br>局部变量是在用户栈中，是线程私有的内存区域，所以也不存在线程安全问题。</li>\n</ul>\n<p>所以很清楚，Spring对Bean的多线程安全问题并没有做出任何保证或措施，对于每个Bean不存在线程安全问题，根本原因是这些Bean的设计并没有在Bean中声明任何有状态的实例变量或类变量。如果要做有状态设计，那么可以使用ThreadLocal把变量变成线程私有，而如果Bean的实例变量或者类变量需要在多个线程间共享，那就只能使用synchronized、lock、CAS等实现线程同步了。</p>\n<h3 id=\"HashMap与ConcurrentHashMap\"><a href=\"#HashMap与ConcurrentHashMap\" class=\"headerlink\" title=\"HashMap与ConcurrentHashMap\"></a>HashMap与ConcurrentHashMap</h3><p>前者是非线程安全的，后者是线程安全的。<br>前者允许key，value为空，后者则不允许。<br>前者不允许在通过Iterator遍历同时对HashMap修改（例如使用iterator的remove()），而后者是允许的，并且更新后续可见。<br>ConcurrentHashMap是也通过key的哈希值与数组的长度的取模来确定该key在数组中的索引（是不是有点绕），与以往版本不同的是，在Java8里ConcurrentHashMap的实现做了较大调整，取消了segment分段锁而采用CAS和synchronized来保证并发安全，数据结构采用数组+链表/红黑二叉树的方式实现（当链表中的节点个数超过8个时，转换成红黑树的数据结构来存储。synchronized只锁定当前链表或红黑二叉树的首节点），提高了并发性，寻址效率高。(补充一下，1.8HashMap也不再仅仅是数组+链表形式，也有树了)</p>\n<h4 id=\"概念：fast-fail机制\"><a href=\"#概念：fast-fail机制\" class=\"headerlink\" title=\"概念：fast-fail机制\"></a>概念：fast-fail机制</h4><p>即快速失败机制，是java集合（Collection）中的一种错误检测机制。在迭代集合的过程中该集合在结构上发生改变时，就可能发生fast-fail，即抛出ConcurrentModificationException异常。fast-fail机制并不保证在异步修改一定会抛出异常，它只是“尽最大努力”去抛出，所以这种机制一般仅用于检测bug。<br>推荐阅读：<a href=\"http://www.nowamagic.net/librarys/veda/detail/1202\" target=\"_blank\" rel=\"noopener\">http://www.nowamagic.net/librarys/veda/detail/1202</a> HashMap的存取之美</p>\n","slug":"多线程并发与线程安全","updated":"2019-07-21T00:32:00.560Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/20/多线程并发与线程安全/","excerpt":"死锁四个必要条件： 互斥条件 请求和保持条件 不剥夺条件 环路等待条件","categories":[{"name":"Java杂谈","slug":"Java杂谈","permalink":"https://nojejesus.github.io/techTube/categories/Java杂谈/"}],"tags":[{"name":"并发","slug":"并发","permalink":"https://nojejesus.github.io/techTube/tags/并发/"},{"name":"线程安全","slug":"线程安全","permalink":"https://nojejesus.github.io/techTube/tags/线程安全/"},{"name":"多线程","slug":"多线程","permalink":"https://nojejesus.github.io/techTube/tags/多线程/"}]},{"title":"CountDownLatch","date":"2019-07-20T03:59:55.000Z","path":"2019/07/20/CountDownLatch/","text":"待添加","raw":"---\ntitle: CountDownLatch\ndate: 2019-07-20 11:59:55\ntags:\n- CountDownLatch\n- 并发\ncategories: \n- Java杂谈\n---\n\n##### 待添加\n<!-- more -->","content":"<h5 id=\"待添加\"><a href=\"#待添加\" class=\"headerlink\" title=\"待添加\"></a>待添加</h5><a id=\"more\"></a>","slug":"CountDownLatch","updated":"2019-07-20T15:00:10.370Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/20/CountDownLatch/","excerpt":"待添加","categories":[{"name":"Java杂谈","slug":"Java杂谈","permalink":"https://nojejesus.github.io/techTube/categories/Java杂谈/"}],"tags":[{"name":"CountDownLatch","slug":"CountDownLatch","permalink":"https://nojejesus.github.io/techTube/tags/CountDownLatch/"},{"name":"并发","slug":"并发","permalink":"https://nojejesus.github.io/techTube/tags/并发/"}]},{"title":"Spring Cloud","date":"2019-07-19T15:17:40.000Z","path":"2019/07/19/Spring-Cloud/","text":"Just do IT Do more IT","raw":"---\ntitle: Spring Cloud\ndate: 2019-07-19 23:17:40\ntags: #标签\n- Spring Cloud\n- 框架\ncategories: #分类\n- Spring框架\n- Spring Cloud\n---\n\n### Just do IT\n\n<div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/lakers1.jpg\" />\n</div>\n\n<!-- more -->\n\n-------------------------------------------------------------------\n\n### Do more IT\n\n<div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/rocket1.jpg\" />\n</div>\n\n","content":"<h3 id=\"Just-do-IT\"><a href=\"#Just-do-IT\" class=\"headerlink\" title=\"Just do IT\"></a>Just do IT</h3><div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/lakers1.jpg\">\n</div>\n\n<a id=\"more\"></a>\n\n<hr>\n<h3 id=\"Do-more-IT\"><a href=\"#Do-more-IT\" class=\"headerlink\" title=\"Do more IT\"></a>Do more IT</h3><div align=\"center\">\n    <img src=\"https://raw.githubusercontent.com/Nojejesus/techTube/master/images/rocket1.jpg\">\n</div>\n\n","slug":"Spring-Cloud","updated":"2019-07-24T13:57:23.558Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/Spring-Cloud/","excerpt":"Just do IT","categories":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/"},{"name":"Spring Cloud","slug":"Spring框架/Spring-Cloud","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/Spring-Cloud/"}],"tags":[{"name":"框架","slug":"框架","permalink":"https://nojejesus.github.io/techTube/tags/框架/"},{"name":"Spring Cloud","slug":"Spring-Cloud","permalink":"https://nojejesus.github.io/techTube/tags/Spring-Cloud/"}]},{"title":"Spring Boot","date":"2019-07-19T11:10:28.000Z","path":"2019/07/19/Spring-Boot/","text":"Spring Boot","raw":"---\ntitle: Spring Boot\ndate: 2019-07-19 19:10:28\ntags: #标签\n- Spring Boot\n- 框架\ncategories: #分类\n- Spring框架\n- Spring Boot\n---\n\n##### Spring Boot\n\n<!-- more -->\n\n","content":"<h5 id=\"Spring-Boot\"><a href=\"#Spring-Boot\" class=\"headerlink\" title=\"Spring Boot\"></a>Spring Boot</h5><a id=\"more\"></a>\n\n","slug":"Spring-Boot","updated":"2019-07-24T13:57:57.327Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/Spring-Boot/","excerpt":"Spring Boot","categories":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/"},{"name":"Spring Boot","slug":"Spring框架/Spring-Boot","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/Spring-Boot/"}],"tags":[{"name":"Spring Boot","slug":"Spring-Boot","permalink":"https://nojejesus.github.io/techTube/tags/Spring-Boot/"},{"name":"框架","slug":"框架","permalink":"https://nojejesus.github.io/techTube/tags/框架/"}]},{"title":"线程池","date":"2019-07-19T07:31:49.000Z","path":"2019/07/19/线程池/","text":"ThreadPoolExecutorgraph LR; RUNNING--\"shutdown()\"-->SHUTDOWN; RUNNING--\"shutdownNow()\"-->STOP; SHUTDOWN--\"阻塞队列为空，线程池中的工作数量为0\"-->TIDYING; STOP--线程池中的工作线程数量为0-->TIDYING; TIDYING--\"terminated()\"-->TERMINATED; 监控线程池 getTaskCount(): 线程池已执行和未执行的任务总数 getCompletedTaskCount(): 已完成的任务数量 getPoolSize(): 线程池当前的线程数量 getActiveCount(): 当前线程池中正在执行任务的线程总数 线程池的合理配置 cpu密集型任务，就需要尽量压榨CPU，参考值可以设置为NCPU+1IO密集型任务，参考值可以设置为2*NCPU 这只是参考值，并不代表随时随地拿线程池来用，要根据实际场景来分析选择以及参数的配置。例如，在开发企业级权限系统中，部门数的生成过程尝试使用线程池，结果是反而变慢，因为线程池里面的任务都很小（小到任务生成的时间和调度管理时间都很接近），这就造成资源浪费了。 关于用到newCachedThreadPool线程池可能会遇到的问题newCachedThreadPool的源码 12345public static ExecutorService newCachedThreadPool() &#123; return new ThreadPoolExecutor(0, Integer.MAX_VALUE, 60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());&#125; 可以看到它允许的线程数为Integer.MAX_VALUE，这代表可以无限大，因为线程数可以这么多，所以会可能导致OOM问题，要解决这个问题，根本上要自己定义个方法，给线程数设置一个合理的上限，例如： 1return new ThreadPoolExecutor(0,1024，60L, TimeUnit.SECONDS, new SynchronousQueue&lt;Runnable&gt;());","raw":"---\ntitle: 线程池\ndate: 2019-07-19 15:31:49\ntags: #标签\n- 线程池\ncategories: #分类\n- Java杂谈\n---\n### ThreadPoolExecutor\n\n```mermaid\ngraph LR;\n    RUNNING--\"shutdown()\"-->SHUTDOWN;\n    RUNNING--\"shutdownNow()\"-->STOP;\n    SHUTDOWN--\"阻塞队列为空，线程池中的工作数量为0\"-->TIDYING;\n    STOP--线程池中的工作线程数量为0-->TIDYING;\n    TIDYING--\"terminated()\"-->TERMINATED;\n```\n\n+ 监控线程池\n- getTaskCount(): 线程池已执行和未执行的任务总数\n- getCompletedTaskCount(): 已完成的任务数量\n- getPoolSize(): 线程池当前的线程数量\n- getActiveCount(): 当前线程池中正在执行任务的线程总数\n\n<!-- more -->\n\n##### 线程池的合理配置\n>>cpu密集型任务，就需要尽量压榨CPU，参考值可以设置为NCPU+1\n>>IO密集型任务，参考值可以设置为2*NCPU\n\n>>这只是参考值，并不代表随时随地拿线程池来用，要根据实际场景来分析选择以及参数的配置。例如，在开发企业级权限系统中，部门数的生成过程尝试使用线程池，结果是反而变慢，因为线程池里面的任务都很小（小到任务生成的时间和调度管理时间都很接近），这就造成资源浪费了。\n\n##### 关于用到newCachedThreadPool线程池可能会遇到的问题\n\nnewCachedThreadPool的源码\n```java\npublic static ExecutorService newCachedThreadPool() {\n   return new ThreadPoolExecutor(0, Integer.MAX_VALUE,\n                                 60L, TimeUnit.SECONDS,\n                                 new SynchronousQueue<Runnable>());\n}\n```\n可以看到它允许的线程数为Integer.MAX_VALUE，这代表可以无限大，因为线程数可以这么多，所以会可能导致OOM问题，要解决这个问题，根本上要自己定义个方法，给线程数设置一个合理的上限，例如：\n```java\nreturn new ThreadPoolExecutor(0,1024，60L, TimeUnit.SECONDS, new SynchronousQueue<Runnable>());\n```\n\n","content":"<h3 id=\"ThreadPoolExecutor\"><a href=\"#ThreadPoolExecutor\" class=\"headerlink\" title=\"ThreadPoolExecutor\"></a>ThreadPoolExecutor</h3><pre class=\"mermaid\">graph LR;\n    RUNNING--\"shutdown()\"-->SHUTDOWN;\n    RUNNING--\"shutdownNow()\"-->STOP;\n    SHUTDOWN--\"阻塞队列为空，线程池中的工作数量为0\"-->TIDYING;\n    STOP--线程池中的工作线程数量为0-->TIDYING;\n    TIDYING--\"terminated()\"-->TERMINATED;</pre>\n\n<ul>\n<li>监控线程池</li>\n</ul>\n<ul>\n<li>getTaskCount(): 线程池已执行和未执行的任务总数</li>\n<li>getCompletedTaskCount(): 已完成的任务数量</li>\n<li>getPoolSize(): 线程池当前的线程数量</li>\n<li>getActiveCount(): 当前线程池中正在执行任务的线程总数</li>\n</ul>\n<a id=\"more\"></a>\n\n<h5 id=\"线程池的合理配置\"><a href=\"#线程池的合理配置\" class=\"headerlink\" title=\"线程池的合理配置\"></a>线程池的合理配置</h5><blockquote>\n<blockquote>\n<p>cpu密集型任务，就需要尽量压榨CPU，参考值可以设置为NCPU+1<br>IO密集型任务，参考值可以设置为2*NCPU</p>\n</blockquote>\n</blockquote>\n<blockquote>\n<blockquote>\n<p>这只是参考值，并不代表随时随地拿线程池来用，要根据实际场景来分析选择以及参数的配置。例如，在开发企业级权限系统中，部门数的生成过程尝试使用线程池，结果是反而变慢，因为线程池里面的任务都很小（小到任务生成的时间和调度管理时间都很接近），这就造成资源浪费了。</p>\n</blockquote>\n</blockquote>\n<h5 id=\"关于用到newCachedThreadPool线程池可能会遇到的问题\"><a href=\"#关于用到newCachedThreadPool线程池可能会遇到的问题\" class=\"headerlink\" title=\"关于用到newCachedThreadPool线程池可能会遇到的问题\"></a>关于用到newCachedThreadPool线程池可能会遇到的问题</h5><p>newCachedThreadPool的源码</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> ExecutorService <span class=\"title\">newCachedThreadPool</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>, Integer.MAX_VALUE,</span><br><span class=\"line\">                                 <span class=\"number\">60L</span>, TimeUnit.SECONDS,</span><br><span class=\"line\">                                 <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>可以看到它允许的线程数为Integer.MAX_VALUE，这代表可以无限大，因为线程数可以这么多，所以会可能导致OOM问题，要解决这个问题，根本上要自己定义个方法，给线程数设置一个合理的上限，例如：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ThreadPoolExecutor(<span class=\"number\">0</span>,<span class=\"number\">1024</span>，<span class=\"number\">60L</span>, TimeUnit.SECONDS, <span class=\"keyword\">new</span> SynchronousQueue&lt;Runnable&gt;());</span><br></pre></td></tr></table></figure>\n\n","slug":"线程池","updated":"2019-07-20T04:11:38.435Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/线程池/","excerpt":"ThreadPoolExecutorgraph LR; RUNNING--\"shutdown()\"-->SHUTDOWN; RUNNING--\"shutdownNow()\"-->STOP; SHUTDOWN--\"阻塞队列为空，线程池中的工作数量为0\"-->TIDYING; STOP--线程池中的工作线程数量为0-->TIDYING; TIDYING--\"terminated()\"-->TERMINATED; 监控线程池 getTaskCount(): 线程池已执行和未执行的任务总数 getCompletedTaskCount(): 已完成的任务数量 getPoolSize(): 线程池当前的线程数量 getActiveCount(): 当前线程池中正在执行任务的线程总数","categories":[{"name":"Java杂谈","slug":"Java杂谈","permalink":"https://nojejesus.github.io/techTube/categories/Java杂谈/"}],"tags":[{"name":"线程池","slug":"线程池","permalink":"https://nojejesus.github.io/techTube/tags/线程池/"}]},{"title":"Spring","date":"2019-07-19T05:10:53.000Z","path":"2019/07/19/Spring/","text":"Spring推荐阅读：Spring源码整体架构spring注解@Component、@Service等自动生成bean的命名规则Spring注解@Component、@Repository、@Service、@Controller区别 Spring单例模式与线程安全 ☆☆☆☆☆","raw":"---\nlayout: _posts\ntitle: Spring\ndate: 2019-07-19 13:10:53\ntags: #标签\n- Spring\ncategories: #分类\n- Spring框架\n- Spring\n---\n### Spring\n推荐阅读：\n[Spring源码整体架构](https://yq.aliyun.com/articles/25646?spm=a2c4e.11153940.0.0.3ab416f8uRJDJu)\n[spring注解@Component、@Service等自动生成bean的命名规则](https://blog.csdn.net/weixin_40571358/article/details/81047887)\n[Spring注解@Component、@Repository、@Service、@Controller区别](https://www.cnblogs.com/yangyi9343/p/6305821.html)\n\n<!-- more -->\n\n[Spring单例模式与线程安全](https://www.cnblogs.com/wxd0108/p/5524756.html) ☆☆☆☆☆","content":"<h3 id=\"Spring\"><a href=\"#Spring\" class=\"headerlink\" title=\"Spring\"></a>Spring</h3><p>推荐阅读：<br><a href=\"https://yq.aliyun.com/articles/25646?spm=a2c4e.11153940.0.0.3ab416f8uRJDJu\" target=\"_blank\" rel=\"noopener\">Spring源码整体架构</a><br><a href=\"https://blog.csdn.net/weixin_40571358/article/details/81047887\" target=\"_blank\" rel=\"noopener\">spring注解@Component、@Service等自动生成bean的命名规则</a><br><a href=\"https://www.cnblogs.com/yangyi9343/p/6305821.html\" target=\"_blank\" rel=\"noopener\">Spring注解@Component、@Repository、@Service、@Controller区别</a></p>\n<a id=\"more\"></a>\n\n<p><a href=\"https://www.cnblogs.com/wxd0108/p/5524756.html\" target=\"_blank\" rel=\"noopener\">Spring单例模式与线程安全</a> ☆☆☆☆☆</p>\n","slug":"Spring","updated":"2019-07-27T13:35:56.558Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/Spring/","excerpt":"Spring推荐阅读：Spring源码整体架构spring注解@Component、@Service等自动生成bean的命名规则Spring注解@Component、@Repository、@Service、@Controller区别","categories":[{"name":"Spring框架","slug":"Spring框架","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/"},{"name":"Spring","slug":"Spring框架/Spring","permalink":"https://nojejesus.github.io/techTube/categories/Spring框架/Spring/"}],"tags":[{"name":"Spring","slug":"Spring","permalink":"https://nojejesus.github.io/techTube/tags/Spring/"}]},{"title":"朝花夕拾","date":"2019-07-19T01:03:37.705Z","path":"2019/07/19/hello-world/","text":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new \"My New Post\" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment","raw":"---\ntitle: 朝花夕拾\n---\nWelcome to [Hexo](https://hexo.io/)! This is your very first post. Check [documentation](https://hexo.io/docs/) for more info. If you get any problems when using Hexo, you can find the answer in [troubleshooting](https://hexo.io/docs/troubleshooting.html) or you can ask me on [GitHub](https://github.com/hexojs/hexo/issues).\n\n<!-- more -->\n\n## Quick Start\n\n### Create a new post\n\n``` bash\n$ hexo new \"My New Post\"\n```\n\nMore info: [Writing](https://hexo.io/docs/writing.html)\n\n### Run server\n\n``` bash\n$ hexo server\n```\n\nMore info: [Server](https://hexo.io/docs/server.html)\n\n### Generate static files\n\n``` bash\n$ hexo generate\n```\n\nMore info: [Generating](https://hexo.io/docs/generating.html)\n\n### Deploy to remote sites\n\n``` bash\n$ hexo deploy\n```\n\nMore info: [Deployment](https://hexo.io/docs/deployment.html)\n","content":"<p>Welcome to <a href=\"https://hexo.io/\" target=\"_blank\" rel=\"noopener\">Hexo</a>! This is your very first post. Check <a href=\"https://hexo.io/docs/\" target=\"_blank\" rel=\"noopener\">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href=\"https://hexo.io/docs/troubleshooting.html\" target=\"_blank\" rel=\"noopener\">troubleshooting</a> or you can ask me on <a href=\"https://github.com/hexojs/hexo/issues\" target=\"_blank\" rel=\"noopener\">GitHub</a>.</p>\n<a id=\"more\"></a>\n\n<h2 id=\"Quick-Start\"><a href=\"#Quick-Start\" class=\"headerlink\" title=\"Quick Start\"></a>Quick Start</h2><h3 id=\"Create-a-new-post\"><a href=\"#Create-a-new-post\" class=\"headerlink\" title=\"Create a new post\"></a>Create a new post</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo new <span class=\"string\">\"My New Post\"</span></span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/writing.html\" target=\"_blank\" rel=\"noopener\">Writing</a></p>\n<h3 id=\"Run-server\"><a href=\"#Run-server\" class=\"headerlink\" title=\"Run server\"></a>Run server</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo server</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/server.html\" target=\"_blank\" rel=\"noopener\">Server</a></p>\n<h3 id=\"Generate-static-files\"><a href=\"#Generate-static-files\" class=\"headerlink\" title=\"Generate static files\"></a>Generate static files</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo generate</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/generating.html\" target=\"_blank\" rel=\"noopener\">Generating</a></p>\n<h3 id=\"Deploy-to-remote-sites\"><a href=\"#Deploy-to-remote-sites\" class=\"headerlink\" title=\"Deploy to remote sites\"></a>Deploy to remote sites</h3><figure class=\"highlight bash\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">$ hexo deploy</span><br></pre></td></tr></table></figure>\n\n<p>More info: <a href=\"https://hexo.io/docs/deployment.html\" target=\"_blank\" rel=\"noopener\">Deployment</a></p>\n","slug":"hello-world","updated":"2019-07-19T20:03:29.006Z","comments":true,"link":"","permalink":"https://nojejesus.github.io/techTube/2019/07/19/hello-world/","excerpt":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.","categories":[],"tags":[]}]}